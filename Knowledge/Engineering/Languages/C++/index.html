<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="![[Knowledge/Engineering/Languages/assets/cpp-wallpaper.png|800]]
C++ is a [[Knowledge/Engineering/Programming/Type System#Static Typing|statically-typed]], low-level programming language that supports [[Knowledge/Engineering/Programming/Object Oriented Programming|object-oriented programming]]. It&rsquo;s frequently used in any software system that requires resource efficiency such as operating systems, game engines, databases, compilers, etc."><title>C++</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://wiki.timz.dev//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://wiki.timz.dev/styles.f0166864fd6bb1603db547f1f970f84b.min.css rel=stylesheet><link href=https://wiki.timz.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://wiki.timz.dev/js/darkmode.773d76aedcd615c64f644f542d60cb1b.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://wiki.timz.dev/js/popover.688c5dcb89a57776d7f1cbeaf6f7c44b.min.js></script>
<script src=https://wiki.timz.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://wiki.timz.dev/js/clipboard.de8d8b2221fe27323078cbd76188e364.min.js></script>
<script>const BASE_URL="https://wiki.timz.dev/",fetchData=Promise.all([fetch("https://wiki.timz.dev/indices/linkIndex.09239f342d9708938281593c85ed3448.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://wiki.timz.dev/indices/contentIndex.7939b14f8caa7709438141c7d782a5ff.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://wiki.timz.dev",t,[{"/Knowledge/Engineering":"#4388cc"},{"/Knowledge/Investing":"#98c379"},{"/Knowledge/Personal-Finance":"#98c379"},{"/Knowledge/Finance":"#FFD700"},{"/Knowledge/Economics":"#FFD700"}],t?{centerForce:1,depth:3,enableDrag:!0,enableLegend:!0,enableZoom:!0,fontSize:.4,linkDistance:1,opacityScale:3,repelForce:.2,scale:1.4}:{centerForce:1,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:1,scale:3}),initPopover("https://wiki.timz.dev",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://wiki.timz.dev/js/search.cf33b507388f3dfd5513a2afcda7af41.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://wiki.timz.dev/js/graph.0ac96ed5ea296a8b1ac03a6eba11878c.js></script><div class=singlePage><header><h1 id=page-title><a href=https://wiki.timz.dev/>🌱 Tim's Dev Wiki</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>C++</h1><p class=meta>Last updated December 17, 2022.</p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#copy-list-and-direct-initialisation>Copy, List and Direct Initialisation</a><ol><li></li></ol></li><li><a href=#pointers-and-references>Pointers and References</a><ol><li><a href=#pointers>Pointers</a></li><li><a href=#references>References</a></li></ol></li><li><a href=#type-qualifiers-auto-const-constexpr-static>Type Qualifiers: auto, const, constexpr, static</a><ol><li><a href=#auto>Auto</a></li><li><a href=#const>Const</a></li><li><a href=#constexpr>Constexpr</a></li><li><a href=#static>Static</a></li><li><a href=#clockwise-spiral-rule>Clockwise-Spiral Rule</a></li></ol></li><li><a href=#io>IO</a></li><li><a href=#arrays>Arrays</a><ol><li><a href=#pointers-vs-arrays>Pointers vs. Arrays</a></li></ol></li><li><a href=#l-values-and-r-values>L-Values and R-Values</a><ol><li><a href=#l-value-and-r-value-references>L-value and R-value References</a></li></ol></li><li><a href=#modularity>Modularity</a><ol><li><a href=#separate-compilation>Separate Compilation</a></li><li><a href=#namespaces>Namespaces</a></li></ol></li><li><a href=#error-handling>Error Handling</a><ol><li><a href=#custom-exceptions>Custom Exceptions</a></li><li><a href=#noexcept>noexcept</a></li></ol></li><li><a href=#classes>Classes</a><ol><li></li><li><a href=#move-constructor-todo>Move Constructor [TODO]</a></li></ol></li></ol><ol><li><ol><li><a href=#others>Others:</a></li></ol></li><li><a href=#functions>Functions</a><ol><li><a href=#functors-function-objects>Functors (Function Objects):</a></li><li><a href=#lambda-functions-anonymous-functors>Lambda Functions (Anonymous Functors):</a></li></ol></li><li><a href=#classes-1>Classes</a><ol><li><a href=#instantiating-classes-todo>Instantiating Classes: [TODO]</a></li><li><a href=#oop>OOP:</a></li><li><a href=#misc>Misc:</a></li></ol></li><li><a href=#enums>Enums</a></li><li><a href=#modules-todo>Modules [TODO]</a><ol><li><a href=#using-todo>Using [TODO]</a></li><li><a href=#exception-handling-todo>Exception Handling [TODO]</a></li><li><a href=#asserts-todo>Asserts [TODO]</a></li><li><a href=#casts-todo>Casts [TODO]</a></li><li><a href=#initializer-list-todo>Initializer List [TODO]</a></li><li><a href=#extern-todo>Extern [TODO]</a></li><li><a href=#volatile-todo>Volatile [TODO]</a></li><li><a href=#decltype-todo>Decltype [TODO]</a></li><li><a href=#templates>Templates</a></li></ol></li><li><a href=#templates-1><strong>Templates:</strong></a><ol><li><a href=#function-templates>Function Templates:</a></li><li><a href=#class-templates>Class Templates:</a></li></ol></li></ol><ol><li><ol><li><a href=#how-c-compilation-works>How C++ Compilation Works:</a></li><li><a href=#curly-braces-in-c>Curly Braces in C++:</a></li><li><a href=#union>Union:</a></li><li><a href=#struct>Struct:</a></li><li><a href=#structured-binding>Structured Binding:</a></li></ol></li></ol><ol><li><ol><li><a href=#style-guide>Style Guide</a></li><li><a href=#soruce-code-documentation>Soruce Code Documentation</a></li></ol></li></ol></nav></details></aside><p><img src=/Knowledge/Engineering/Languages/assets/cpp-wallpaper.png width=800></p><p>C++ is a <a href=/Knowledge/Engineering/Programming/Type-System#static-typing rel=noopener class=internal-link data-src=/Knowledge/Engineering/Programming/Type-System>statically-typed</a>, low-level programming language that supports <a href=/Knowledge/Engineering/Programming/Object-Oriented-Programming rel=noopener class=internal-link data-src=/Knowledge/Engineering/Programming/Object-Oriented-Programming>object-oriented programming</a>. It&rsquo;s frequently used in any software system that requires resource efficiency such as operating systems, game engines, databases, compilers, etc.</p><p>C/C++&rsquo;s high performance is attributed to how closely it&rsquo;s constructs and operations match the hardware.</p><p>The <strong><a href=https://isocpp.org/std/-the-standard rel=noopener>ISO C++ standard</a></strong> defines:</p><ul><li>Core language features — data types, loops, etc.</li><li>Standard library components — <code>vector</code>, <code>map</code>, <code>string</code>, etc.</li></ul><p>Also see <a href=/Knowledge/Engineering/Languages/C++-Standard-Library rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++-Standard-Library>C++ standard library</a>.</p><a href=#basics><h1 id=basics><span class=hanchor arialabel=Anchor># </span>Basics</h1></a><a href=#copy-list-and-direct-initialisation><h2 id=copy-list-and-direct-initialisation><span class=hanchor arialabel=Anchor># </span>Copy, List and Direct Initialisation</h2></a><p>There are a few ways to initialise a variable with a value.</p><ol><li><strong>Copy initialisation</strong>: using <code>=</code>. It implicitly calls a constructor.</li><li><strong>List initialisation</strong>, also called <strong>uniform initialisation</strong>: using <code>{ }</code>.</li><li><strong>Direct initialisation</strong>: using <code>( )</code>. Think of the parentheses as being used to <em>directly</em> invoke a specific constructor.</li></ol><blockquote><p>Prefer uniform initialisation over copy initialisation.</p></blockquote><pre><code>```cpp
int b(1);     // Direct initialisation.
int a{1};     // List initialisation.
int c = 1;    // Copy initialisation.
int d = {1};  // Copy/List initialisation.
```
</code></pre><ul><li><em>List initialisation</em> does not allow <em>narrowing</em>. Try to use list initialisation <code>{ }</code> more often.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mf>7.8</span><span class=p>;</span>  <span class=c1>// Gets floored to 7
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>i</span><span class=p>{</span><span class=mf>7.8</span><span class=p>};</span>   <span class=c1>// Error: narrowing conversion from &#39;double&#39; to &#39;int&#39;
</span></span></span></code></pre></td></tr></table></div></div></li><li><code>explicit</code> constructors are <em>not invokable</em> with copy initialisation.</li></ul><a href=#designated-initialisers><h4 id=designated-initialisers><span class=hanchor arialabel=Anchor># </span>Designated Initialisers</h4></a><p>C++20 introduces a new way to initialise the members of a class/struct:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Human</span> <span class=n>andrew</span><span class=p>{</span> <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Andrew&#34;</span><span class=p>,</span> <span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>42</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Human</span> <span class=n>linus</span><span class=p>{</span> <span class=p>.</span><span class=n>name</span><span class=p>{</span><span class=s>&#34;Linus&#34;</span><span class=p>}</span> <span class=p>};</span>               <span class=c1>// You can also use list initialisation on the members.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>Human</span> <span class=n>ada</span><span class=p>{</span> <span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>36</span><span class=p>,</span> <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Ada&#34;</span> <span class=p>};</span>       <span class=c1>// Error. You must initialise the fields in the same order as they&#39;re declared in the struct/class.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#pointers-and-references><h2 id=pointers-and-references><span class=hanchor arialabel=Anchor># </span>Pointers and References</h2></a><p>Pointers and references are really the same thing under the hood, however they have different semantics to the programmer. You can consider references as syntactic sugar for pointers whose main purpose is to help you write cleaner code, compared to if you were to use pointers for the same use case.</p><blockquote><p>Unlike other languages, in C++, arguments <em><strong>are always passed by value
<a href=https://www.learncpp.com/cpp-tutorial/passing-arguments-by-value rel=noopener>by default</a></strong></em> <em>unless the function signature explicitly says it takes in a pointer or reference</em>. This means functions will <strong>entirely copy</strong> all the objects you pass in, unless you pass in a pointer/reference.</p></blockquote><blockquote><p><code>*</code> and <code>&</code> have different meanings depending on whether they appear in a type declaration (LHS) or whether they appear in an expression that is to be evaluated (RHS).</p></blockquote><p>In a <em>type</em> <em>declaration</em>:</p><ul><li><code>*</code> defines a <strong>pointer type</strong>. <code>int* arr;</code></li><li><code>&</code> defines a <strong>reference variable</strong>.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>In an <em>expression</em>:</p><ul><li><code>*</code> is the unary <strong>dereference</strong> <strong>operator</strong> that dereferences an address to evaluate to the contents at that address.</li><li><code>&</code> is the unary <strong>address-of operator</strong> that evaluates to the address of a variable. <code>&</code> always expects an <a href=/Knowledge/Engineering/Languages/C++#l-values-and-r-values rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>lvalue</a>.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>&amp;</span><span class=n>i</span>         <span class=c1>// → Eg. 0x7FFEF2BA1884
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&amp;&amp;</span><span class=n>i</span>        <span class=c1>// → Illegal operation. &amp;(0x7FFEF2BA1884) doesn&#39;t make sense.
</span></span></span></code></pre></td></tr></table></div></div></li></ul><a href=#pointers><h3 id=pointers><span class=hanchor arialabel=Anchor># </span>Pointers</h3></a><p>Pointers are just memory addresses, often to the contents of an object allocated on the heap.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>q</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>q</span><span class=p>;</span>          <span class=c1>// p now contains the memory address of y.
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/pointers-illustrated.png width=590 alt="illustration of pointers|590"></p><ul><li><code>nullptr</code>. C++ requires that <code>NULL</code> is a constant that has value <code>0</code>. Unlike in C, <code>NULL</code> cannot be defined as <code>(void *)</code><ul><li><code>nullptr</code> therefore exists to distinguish between 0 and an <em>actual null</em> for pointer types. People would otherwise mistakenly use <code>NULL</code> and not realise it is just 0</li></ul></li><li><strong>Note</strong>:
<a href=https://stackoverflow.com/questions/6990726/correct-way-of-declaring-pointer-variables-in-c-c/6990753 rel=noopener>Stroustrup prefers</a> the pointer declaration style <code>int* p</code> in C++ and <code>int *p</code> in C.</li></ul><a href=#references><h3 id=references><span class=hanchor arialabel=Anchor># </span>References</h3></a><p>You can think of a reference variable as an alias for another variable. They don’t occupy any memory themselves, once your program is compiled and running.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>r</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>r2</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>r2</span><span class=p>;</span>      <span class=c1>// Remember, you can think of references as aliases. This assignment is basically just `x = y`
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/references-illustrated.png width=600 alt="illustration of references|600"></p><ul><li>References are useful as function parameters to avoid copying the entire argument. <strong>In C++, pass-by-value is the default</strong>, although <em>copy elision</em> can happen which nullifies the performance impact of making a copy of an object.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>sequence</span><span class=p>);</span>    <span class=c1>// Will sort the given sequence, in-place.
</span></span></span></code></pre></td></tr></table></div></div></li><li>Const references are useful for when you don&rsquo;t want to modify an argument and <strong>just want to read its contents</strong>. It prevents the need to make a copy of that argument for the function&rsquo;s scope. This is really common practice:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getAverage</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>sequence</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li>References must be initialised and can’t be reassigned afterwards.</li><li>When you return a reference, you are &lsquo;<em>granting the caller access to something that isn&rsquo;t local to the function</em>&rsquo;. It is an error to return a reference to a local variable.</li></ul><a href=#type-qualifiers-auto-const-constexpr-static><h2 id=type-qualifiers-auto-const-constexpr-static><span class=hanchor arialabel=Anchor># </span>Type Qualifiers: auto, const, constexpr, static</h2></a><a href=#auto><h3 id=auto><span class=hanchor arialabel=Anchor># </span>Auto</h3></a><p>When specifying the data type of something as <code>auto</code>, C++ automatically infers the type.</p><ul><li>Use <code>auto</code> for concision, especially when long generic types are involved.</li><li>It&rsquo;s fine to use <a href=/Knowledge/Engineering/Languages/C++#variables rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>copy initialisation</a> if you use <code>auto</code> since type narrowing won&rsquo;t be a problem. E.g. <code>auto x = 1</code>.</li><li>Always assume that <code>auto</code>, by itself, will make a copy of the RHS. Use <code>auto&</code> if copying is undesirable (such as when copying large vectors).</li></ul><a href=#const><h3 id=const><span class=hanchor arialabel=Anchor># </span>Const</h3></a><p>The <code>const</code> qualifier makes it &lsquo;impossible&rsquo; to assign a new value to a variable after it&rsquo;s initialised. There is 0 negative performance impact of enforcing <code>const</code> since it&rsquo;s all done at compile-time. Using const can actually allow the compiler to make optimisations.</p><blockquote><p>Prefer making things const by default. See
<a href=https://isocpp.org/wiki/faq/const-correctness rel=noopener>const correctness</a> for a pitch on why.</p></blockquote><ul><li><code>const</code> and <code>constexpr</code>— immutable variables. Declaring and initialising a <code>const</code> variable will make the compiler guarantee that its value is never modified, ever.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>      
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>j</span> <span class=p>{</span><span class=mi>2</span><span class=p>};</span>      <span class=c1>// You can put **const** before pretty much any variable declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// With **const**, you can assign it a value that is determined during runtime.
</span></span></span><span class=line><span class=cl><span class=c1>// With **constexpr**, you can only assign it values known at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=n>cube</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>    <span class=c1>// Error, *unless cube is defined as a [**constexpr function**](https://www.ibm.com/docs/es/xl-c-and-cpp-aix/16.1?topic=functions-constexpr-c11)*
</span></span></span></code></pre></td></tr></table></div></div></li></ul><a href=#const-pointers><h4 id=const-pointers><span class=hanchor arialabel=Anchor># </span>Const Pointers</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>               <span class=c1>// A pointer to an immutable int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>q</span> <span class=o>=</span> <span class=p>...;</span>  <span class=c1>// An immutable pointer to an immutable int. It must be initialised with a memory address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>r</span> <span class=o>=</span> <span class=p>...;</span>        <span class=c1>// An immutable pointer to an int. It must be initisalised with a memory address.
</span></span></span></code></pre></td></tr></table></div></div><p>If this is hard to read, see the <a href=/Knowledge/Engineering/Languages/C++#clockwise-spiral-rule rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>clockwise-spiral rule</a>.</p><a href=#const-references><h4 id=const-references><span class=hanchor arialabel=Anchor># </span>Const References</h4></a><p>Typing a variable as a const reference makes it a read-only alias. It&rsquo;s especially helpful for function parameters.</p><blockquote><p>Prefer typing function parameters as const references. This gives the caller confidence that what they pass in is not modified in any way.</p></blockquote><p>If you don&rsquo;t want a function to modify a caller&rsquo;s argument, you have these options:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo1</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>   <span class=c1>// Preferred approach.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo2</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>s</span><span class=p>);</span>   <span class=c1>// A pointer to a const also works.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo3</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>);</span>          <span class=c1>// Since pass-by-value is the default, `s` is an independent copy of what the caller passed in.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// If you want a parameter to be modifiable:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>bar1</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>         <span class=c1>// This might modify the caller&#39;s string directly.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>bar1</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>s</span><span class=p>);</span>         <span class=c1>// So can this.
</span></span></span></code></pre></td></tr></table></div></div><p>You can&rsquo;t have 100% certainty that what you pass as a const reference is unchanged. See
<a href=https://isocpp.org/wiki/faq/const-correctness#return-const-ref-from-const-memfn rel=noopener>this example from isocpp</a>:</p><a href=#const-methods><h4 id=const-methods><span class=hanchor arialabel=Anchor># </span>Const Methods</h4></a><p>Const methods can only read <code>this</code> and never mutate anything about it. To specify a const method, the <code>const</code> qualifier <em>must</em> be placed after the parameter list.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>inspect</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>What about making methods <strong>return const values</strong>, eg. <code>const Foo bar();</code>?
<a href=https://stackoverflow.com/questions/8716330/purpose-of-returning-by-const-value rel=noopener>It&rsquo;s <em>mostly</em> pointless</a>. However, it is <em>not</em> pointless if you&rsquo;re returning a pointer or reference to something that is const.</p></blockquote><a href=#constexpr><h3 id=constexpr><span class=hanchor arialabel=Anchor># </span>Constexpr</h3></a><p>The <code>constexpr</code> type specifier is like <code>const</code>, except the RHS value must be able to be determined at compile-time.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>some_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#constexpr-functions><h4 id=constexpr-functions><span class=hanchor arialabel=Anchor># </span>Constexpr Functions</h4></a><p>Constexpr functions are those than <em>can</em> be executed at compile-time, meaning all its state and behaviour is determinable at compile-time.</p><a href=#static><h3 id=static><span class=hanchor arialabel=Anchor># </span>Static</h3></a><a href=#static-variables><h4 id=static-variables><span class=hanchor arialabel=Anchor># </span>Static Variables</h4></a><p>Inside functions, static variables let you share a value across all calls to that function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>    <span class=c1>// All calls to **foo** will see **a = 42**.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>                   <span class=c1>// If **a** changes, then all calls to **foo** will see that change too
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Static function variables are <strong>generally considered bad</strong> because they represent global state and are therefore much more difficult to reason about
<a href="https://stackoverflow.com/questions/7026507/why-are-static-variables-considered-evil#:~:text=Static-variables-are-generally-considered,assumptions-of-object%2Doriented-programming." rel=noopener>*</a>.</p></blockquote><a href=#clockwise-spiral-rule><h3 id=clockwise-spiral-rule><span class=hanchor arialabel=Anchor># </span>Clockwise-Spiral Rule</h3></a><p><a href=http://c-faq.com/decl/spiral.anderson.html rel=noopener>Clockwise-Spiral Rule</a> is a trick for reading variable types.</p><ol><li>Start at the variable name.</li><li>Follow an outwards clockwise spiral from that variable name to build up a sentence.</li></ol><p><strong>Example</strong>:
<img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/clockwise-spiral.png width=400 alt="clockwise-spiral rule example|400">
Starting at the name <code>fp</code>:</p><ol><li><code>fp</code> is a pointer.</li><li><code>fp</code> is a pointer to a function (that takes in an <code>int</code> and a <code>float</code> pointer).</li><li><code>fp</code> is a pointer to a function (that takes in an <code>int</code> and a <code>float</code> pointer) that returns a pointer.</li><li><code>fp</code> is a pointer to a function (that takes in an <code>int</code> and a <code>float</code> pointer) that returns a pointer to a char.</li></ol><p>More examples:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>myVar</span><span class=p>;</span>                     <span class=c1>// pointer to an int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>const</span> <span class=o>*</span><span class=n>myVar</span><span class=p>;</span>               <span class=c1>// pointer to a const int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>myVar</span> <span class=o>=</span> <span class=p>...;</span>        <span class=c1>// const pointer to an int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>const</span> <span class=o>*</span> <span class=k>const</span> <span class=n>myVar</span> <span class=o>=</span> <span class=p>...;</span>  <span class=c1>// const pointer to a const int.
</span></span></span></code></pre></td></tr></table></div></div><a href=#io><h2 id=io><span class=hanchor arialabel=Anchor># </span>IO</h2></a><p><code>&lt;&lt;</code> — the <strong>&lsquo;put to&rsquo;</strong> operator. In <code>arg1 &lt;&lt; arg2</code>, the <code>&lt;&lt;</code> operator takes the second argument and writes it into the first.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Meaning of life: &#34;</span> <span class=o>&lt;&lt;</span> <span class=mi>42</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>>></code> — the <strong>&lsquo;get from&rsquo;</strong> operator. In <code>arg1 >> arg2</code>, the <code>>></code> operator gets a value from <code>arg1</code> and assigns it to <code>arg2</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>std::endl</code> is a newline that flushes the output buffer, which means it is less performant than <code>"\n"</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>             <span class=c1>// Adds a &#34;\n&#34; and flushes the output buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>             <span class=c1>// Adds a &#34;\n&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>flush</span><span class=p>;</span>    <span class=c1>// Adds a &#34;\n&#34; and flushes the output buffer.
</span></span></span></code></pre></td></tr></table></div></div><p>See <a href=/Knowledge/Engineering/Languages/C++-Standard-Library#io rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++-Standard-Library>C++ Standard Library IO</a> for more complex IO operations.</p><a href=#arrays><h2 id=arrays><span class=hanchor arialabel=Anchor># </span>Arrays</h2></a><p>The many ways of initialising arrays:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>                    <span class=c1>// [?, ?, ?, ?] – array is full of garbage values, often zeroes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  <span class=p>};</span>             <span class=c1>// [0, 0, 0, 0] – all elements set to 0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>   <span class=c1>// [1, 2, 3, 4].
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span>            <span class=c1>// [1, 0, 0, 0] – the rest of array is zeroed.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>    <span class=c1>// Array size can be omitted if it can be inferred from RHS.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[]</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>      <span class=c1>// You can use uniform initialisation instead of copy initialisation.
</span></span></span></code></pre></td></tr></table></div></div><p>The size of the array must be able to be determined at compile-time.</p><a href=#pointers-vs-arrays><h3 id=pointers-vs-arrays><span class=hanchor arialabel=Anchor># </span>Pointers vs. Arrays</h3></a><p>What&rsquo;s the difference between <code>int* array</code> and <code>int array[]</code>? They both can be used to access a sequence of data and are mostly interchangeable.</p><p>The main difference is in <strong>runtime allocation and resizing</strong>: <code>int* array</code> is far more flexible, allowing allocation/deallocation and resizing during runtime, whereas <code>int array[]</code> cannot be resized after declaration.</p><blockquote><p>In general, <em>prefer using declaring <strong>true array-types</strong> with <code>[]</code> over pointers-type arrays with <code>*</code></em>. It&rsquo;s less error-prone (because you don&rsquo;t have to worry about dynamic allocation and remembering to free allocated memory) and more readable.</p></blockquote><a href=#l-values-and-r-values><h2 id=l-values-and-r-values><span class=hanchor arialabel=Anchor># </span>L-Values and R-Values</h2></a><p>An <strong>lvalue</strong> is a memory location that identifies an object. <strong>Variables are lvalues</strong>.</p><blockquote><p>In C: an <em>lvalue</em> is an expression that can appear on the LHS <em><strong>or</strong></em> RHS of an assignment.</p></blockquote><p>An <strong>rvalue</strong> is a value stored at some memory address. Rvalues are different from lvalues in that <strong>they cannot have a value assigned to it</strong>, which means it can’t ever be on the LHS part of an assignment. <strong>Literals are typically rvalues</strong>.</p><blockquote><p>In C: an <em>rvalue</em> is an expression that can only appear on the RHS of an assignment.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>    <span class=c1>// i is an lvalue, 10 is an rvalue.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>2</span>  <span class=c1>// i * 2 is an rvalue.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>2</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>         <span class=c1>// error: expression must be a modifiable lvalue.
</span></span></span></code></pre></td></tr></table></div></div><ul><li>Rvalues are important because they <strong>enable move semantics</strong> in C++. There are many instances in C++ code where it’s not necessary to copy a value or object from one place to another. E.g. when passing arguments into a function or when saving the returned value on the caller’s side. Implementing move semantics, where appropriate, is great for performance because it prevents expensive copies.</li></ul><a href=#l-value-and-r-value-references><h3 id=l-value-and-r-value-references><span class=hanchor arialabel=Anchor># </span>L-value and R-value References</h3></a><p>An <strong>lvalue reference</strong> uses a single ampersand <code>&</code>, eg. <code>string& s = "..."</code></p><ul><li>Const lvalue reference types (eg. <code>const string& s</code>) as a function parameter allow the caller to <strong>pass both an l-value or r-value, equivalently</strong>.</li></ul><p>An <strong>rvalue reference</strong> uses double ampersand <code>&&</code>, eg. <code>string&& s</code>. You’d use this to receive rvalues in functions, like literals and temporary objects. Doing this means you can avoid unnecessarily copying a value that is a ‘throwaway’ on the caller’s side.</p><ul><li>You can define a <em>move constructor</em> and <em>move assignment operator</em> that take in an rvalue reference instead of a const lvalue reference. It’ll behave the same way, but it won’t guarantee the source to be unchanged.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Takes in an l-value reference which forces the caller to pass in variables.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>**</span><span class=n>GreetLvalue</span><span class=o>**</span><span class=p>(</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>    
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Takes in an r-value reference which forces the caller to pass in literals 
</span></span></span><span class=line><span class=cl><span class=c1>// or temporary objects.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>**</span><span class=n>GreetRvalue</span><span class=o>**</span><span class=p>(</span><span class=n>string</span> <span class=o>&amp;&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>   
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>             
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Const references let the caller pass both lvalues and rvalues alike
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>**</span><span class=n>Greet</span><span class=o>**</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>    
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>             <span class=c1>// Note: `const string &amp;` will create a temporary variable behind the
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>                                   <span class=c1>// scenes and then assign it to `name`. This is why you can pass both
</span></span></span><span class=line><span class=cl><span class=c1></span>                                    <span class=c1>// lvalues and rvalues to a const l-value reference like this.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>myName</span> <span class=o>=</span> <span class=s>&#34;Tim&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>GreetLvalue</span><span class=p>(</span><span class=n>myName</span><span class=p>);</span>     <span class=c1>// ✓
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>GreetLvalue</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>   <span class=c1>// Error: cannot bind **non-const lvalue reference**
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>GreetRvalue</span><span class=p>(</span><span class=n>myName</span><span class=p>);</span>     <span class=c1>// Error: cannot bind **rvalue reference**
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>GreetRvalue</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>   <span class=c1>// ✓
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>Greet</span><span class=p>(</span><span class=n>myName</span><span class=p>);</span>           <span class=c1>// ✓
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Greet</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>         <span class=c1>// ✓
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#modularity><h2 id=modularity><span class=hanchor arialabel=Anchor># </span>Modularity</h2></a><a href=#separate-compilation><h3 id=separate-compilation><span class=hanchor arialabel=Anchor># </span>Separate Compilation</h3></a><p>C++ supports <em>separate compilation</em>, where code in one file only sees the declarations for the types and functions it uses, not the implementation. This decouples the smaller units comprising a project and minimises compilation time since each unit can be compiled only if they change.</p><p>We take advantage of separate compilation by listing out declarations in a header file. Example:
![[Knowledge/Engineering/Languages/assets/vector-header-cpp.png|500]]</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Vector.h — the header file defining the Vector class and its properties and methods (but without implementation)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Vector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[[]];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span><span class=o>*</span> <span class=n>elements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Vector.cpp — the implementation for Vector.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;Vector.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Implementing the constructor and methods outside of the class definition.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector</span><span class=o>::</span><span class=n>Vector</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>)</span> <span class=o>:</span><span class=n>elements</span><span class=p>{</span><span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>s</span><span class=p>]},</span> <span class=n>capacity</span><span class=p>{</span><span class=n>s</span><span class=p>}</span> <span class=p>{}</span>   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span><span class=o>&amp;</span> <span class=n>Vector</span><span class=o>::</span><span class=k>operator</span><span class=p>[[]]</span> <span class=p>{</span> <span class=k>return</span> <span class=n>elements</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Vector</span><span class=o>::</span><span class=n>size</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>capacity</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// user.cpp — the user of Vector.h, who has know idea about how it&#39;s implemented.
</span></span></span><span class=line><span class=cl><span class=c1>//            It only knows about the declarations inside Vector.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Vector.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>Vector</span> <span class=n>v</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vector size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#namespaces><h3 id=namespaces><span class=hanchor arialabel=Anchor># </span>Namespaces</h3></a><p>Namespaces <em><strong>define a scope for a set of names</strong></em>. It&rsquo;s used to organise your project into logical groups and to prevent name collisions when you&rsquo;re using libraries, for example.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>UNSW</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>string</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>Student</span><span class=p>(</span><span class=n>string</span> <span class=n>id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>this</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>=</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UNSW</span><span class=o>::</span><span class=n>Student</span> <span class=n>me</span><span class=p>(</span><span class=s>&#34;z5258971&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>me</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Use <code>using</code> to avoid using a fully qualified name every time.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Any identifier you declare that&rsquo;s <em>not within</em> a namespace will be implicitly part of the <em>global namespace</em>. Globally scoped identifiers are accessible with <code>::</code> without specifying a name.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>24</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>;</span>     <span class=c1>// 24. Picks the closer `Foo::num` over `::num`.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>::</span><span class=n>num</span><span class=p>;</span>   <span class=c1>// 42.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#error-handling><h2 id=error-handling><span class=hanchor arialabel=Anchor># </span>Error Handling</h2></a><p>C++ provides the familiar <code>try</code> and <code>catch</code> blocks for error handling. Note that when an exception is thrown, the destructor for the object that threw the exception is called, enabling <a href=/Knowledge/Engineering/Languages/C++#raii rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>RAII</a>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>out_of_range</span><span class=o>&amp;</span> <span class=n>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span><span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// All exceptions are caught here when you use `...`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span><span class=p>;</span>  <span class=c1>// Use `throw` on its own to re-throw the exception.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#custom-exceptions><h3 id=custom-exceptions><span class=hanchor arialabel=Anchor># </span>Custom Exceptions</h3></a><p>Just inherit from <code>std::exception</code>, implement the <code>const char* what() const throw()</code> method, and a constructor that takes in a <code>string</code> error message.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyException</span> <span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>MyException</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>)</span> <span class=o>:</span> <span class=n>message_</span><span class=p>(</span><span class=n>message</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>what</span><span class=p>()</span> <span class=k>const</span> <span class=k>throw</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>message_</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>message_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#noexcept><h3 id=noexcept><span class=hanchor arialabel=Anchor># </span>noexcept</h3></a><p>Use <code>noexcept</code> at the end of a function signature to declare that it will never throw an exception. If it does in fact throw an exception, it will just directly <code>std::terminate()</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>something_bad</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>Why use it?</p><ul><li>The compiler generates slightly more optimal code since it can assume it doesn&rsquo;t have to support try-catch control flow.</li><li>For documentation for other developers.</li></ul><a href=#classes><h2 id=classes><span class=hanchor arialabel=Anchor># </span>Classes</h2></a><a href=#raii><h4 id=raii><span class=hanchor arialabel=Anchor># </span>RAII</h4></a><p>The technique of acquiring resources in the constructor and then freeing them in the destructor is called <em>RAII (Resource Acquisition is Initialisation)</em>. The idea is about coupling the use of a resource to the lifetime of an object so that when it goes out of scope, or when it throws an exception, the resources it held are guaranteed to be released. Always design classes with RAII in mind.</p><ul><li>This works well for mutexes where you can acquire the lock in the constructor and unlock in the destructor.</li></ul><a href=#move-constructor-todo><h3 id=move-constructor-todo><span class=hanchor arialabel=Anchor># </span>Move Constructor [TODO]</h3></a><p>Suppose you have a function that returns a large object (e.g. a big matrix). Since you can&rsquo;t return a reference to a local variable, and it is a bad idea to resort to the C-style returning of a pointer to a <code>new</code> object that the caller has to memory-manage, the best option is to use a move constructor.</p><a href=#quirks><h1 id=quirks><span class=hanchor arialabel=Anchor># </span>Quirks</h1></a><p>Random C++ details you encounter infrequently but which are still good to know.</p><ul><li><strong>Copy elision</strong>: by default, when you pass an object to a function, that object is copied over (pass-by-value). When it doesn&rsquo;t affect program behaviour, the compiler can move the object rather than making a full copy of it. This compiler optimisation can also happen when returning an object, throwing an exception, etc.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;Hello, world!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>str</span><span class=p>;</span>  <span class=c1>// copy elision occurs here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>s</span> <span class=o>=</span> <span class=n>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><strong>if-statement with initialiser</strong>: in C++17, you can declare variables inside <code>if</code> statements and follow it up with a condition: <code>if (init; condition) { ... }</code>.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vector size is not 0&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>size</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vector size is &gt; 2&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><strong><code>noexcept(false)</code></strong>: it&rsquo;s possible to use <code>noexcept(false)</code> in function signatures to say that &rsquo;this function throws no exceptions (but it actually might, lol)&rsquo;. Just avoid using it.</li><li><strong><code>noexcept(true)</code></strong> and <code>noexcept</code> are completely equivalent.</li><li><strong><code>throw()</code></strong>: in older C++, you can put <code>throw()</code> at the end of a function signature to say that the function never throws exceptions, for example: <code>void something_bad() throw()</code>. It&rsquo;s been deprecated by <code>noexcept</code> in C++11, which is preferred over <code>throw()</code>, so you&rsquo;d do: <code>void something_bad() noexcept</code> instead.</li></ul><hr><a href=#old-notes><h1 id=old-notes><span class=hanchor arialabel=Anchor># </span>Old Notes</h1></a><blockquote><p>TODO: This is a huge mess that I&rsquo;ll slowly clean up&mldr;</p></blockquote><a href=#others><h3 id=others><span class=hanchor arialabel=Anchor># </span>Others:</h3></a><ul><li><p><code>new</code> operator — for instantiating classes and creating arrays.
The <code>new</code> operator denotes a request for memory allocation on the heap. If the request can be granted, then it&rsquo;ll evaluate to the memory address of the newly allocated memory and then the constructor will be called.
An object allocated for on the heap will need to be explicitly freed with C++&rsquo;s <code>delete</code> keyword.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>Human</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Constructor has been called&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// **Creating an object** whose memory will be allocated on the heap
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Human</span><span class=o>*</span> <span class=n>me</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Human</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>me</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Creating an array whose memory will be allocated on the heap
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=kt>int</span><span class=o>*</span> <span class=n>A</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>		<span class=k>delete</span> <span class=n>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>B</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>             <span class=c1>// This array will have its memory allocated on the stack, so no **delete** operation is necessary
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Being allocated on the heap means that it is independent of the scope that it was created in and that it&rsquo;ll persist until it is explictly destroyed or until the program ends</li><li>You should
<a href=https://stackoverflow.com/questions/333443/c-object-instantiation rel=noopener>always prefer stack allocations</a> rather than heap allocations<ul><li>This helps avoid memory leaks because when the variable is allocated for in the stack, its <em>destructor</em> is automatically called when leaving its scope</li></ul></li><li>The user of your class should never have to use <code>new</code> and <code>delete</code> in their consuming code</li><li>If you need to allocate a resource like a file handle, socket, etc. it should be wrapped in a class where the constructor acquires the resources, then the destructor frees the resources (guranteeing resource release)<ul><li>This is the basic idea behind
<a href=https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization rel=noopener>RAII</a> — <em>resource allocation is initialisation</em></li></ul></li><li>Avoid using <code>malloc</code> like you would in C</li></ul></li><li><p><code>delete</code> operator — for deallocating objects and arrays allocated on the heap.</p><p>There&rsquo;s two delete operators, <code>delete</code> and <code>delete[]</code>.</p><ul><li><code>delete</code> — for individual objects. It calls the destructor of that single object</li><li><code>delete[]</code> — for arrays. It calls the destructor on each object</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span><span class=o>*</span> <span class=n>courses</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span><span class=o>*</span> <span class=n>zId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Student</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>courses</span> <span class=o>=</span> <span class=k>new</span> <span class=n>string</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>zId</span> <span class=o>=</span> <span class=k>new</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;z5258971&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Student</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>**</span><span class=k>delete</span><span class=p>[]</span> <span class=n>courses</span><span class=o>**</span><span class=p>;</span>       <span class=c1>// Deleting an array
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=o>**</span><span class=k>delete</span> <span class=n>zId</span><span class=o>**</span><span class=p>;</span>             <span class=c1>// Deleting an individual string
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>::</code> <em>scope resolution operator</em> — for unambiguously referencing a name [TODO]</p></li></ul><a href=#functions><h2 id=functions><span class=hanchor arialabel=Anchor># </span>Functions</h2></a><ul><li><p>Overloading</p><p>For functions with the same name, the appropriate function is called depending on which signature matches the call.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=n>string</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>print</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>s</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>print</span><span class=p>(</span><span class=s>&#34;Tim Zhang&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Default parameter values</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>10</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><em>Pass-by-value</em> vs. <em>pass-by-reference</em> for function parameters</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>refVec</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>vec</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>99</span><span class=p>;</span>         <span class=c1>// Only modifies the copied **vec** and does not affect anything on the caller&#39;s side
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>refVec</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>      <span class=c1>// Directly modifies the original vector passed in
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>It&rsquo;s preferred to pass larger values by reference to avoid copying them into the function<ul><li>If a function is only ever expected to read a vector&rsquo;s values, for instance, then it&rsquo;s common to declare it with <code>const vector&lt;int>&</code></li></ul></li></ul></li><li><p><code>auto</code> return type</p><p>You can also use <code>auto</code> in function return types</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>a</span> <span class=o>+</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>It can be convenient for lambdas and functions that return generic types</li></ul></li><li><p><code>inline</code> functions</p><p>You can prefix a function or method signature with the inline keyword. This makes it so the compiler places a copy of the code in that function at each point where the function is called at compile time, meaning that the code is basically copied into the calling function.</p><ul><li>Doing this offers a marginal performance improvement because you avoid allocating a new <a href=/Knowledge/Engineering/Operating-Systems/Stack-Frame rel=noopener class=internal-link data-src=/Knowledge/Engineering/Operating-Systems/Stack-Frame>stack frame</a> that’s usually associated with making a function call<ul><li>This performance improvement is done at the cost of a marginally bigger executable size</li><li><a href=https://softwareengineering.stackexchange.com/questions/254688/why-dont-compilers-inline-everything rel=noopener>Why not make everything inline?</a></li></ul></li><li>You should mainly consider using inline on functions that are very small but called several times in a program</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=kr>inline</span><span class=o>**</span> <span class=kt>void</span> <span class=nf>Func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello world&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><hr><ul><li><em>Hoisting</em> does not exist in C++ or C</li></ul><a href=#functors-function-objects><h3 id=functors-function-objects><span class=hanchor arialabel=Anchor># </span>Functors (Function Objects):</h3></a><p><em>Functors</em>, or <em>function objects</em>, are instances of a regular class that <strong>implements the function call operator method</strong>, <code>operator()</code>, which means that they can called as if they were functions themselves.</p><ul><li><p>Example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=err>**</span><span class=nc>DrinkingLaw</span><span class=o>**</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>DrinkingLaw</span><span class=p>(</span><span class=kt>int</span> <span class=n>requiredAge</span><span class=p>)</span> <span class=o>:</span> <span class=n>requiredAge</span><span class=p>(</span><span class=n>requiredAge</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>**</span><span class=kt>bool</span><span class=o>**</span> <span class=o>**</span><span class=nf>operator</span><span class=p>()(</span><span class=kt>int</span> <span class=n>age</span><span class=p>)</span><span class=o>**</span> <span class=p>{</span>         <span class=c1>// Implementing this method is what makes this class a functor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>age</span> <span class=o>&gt;=</span> <span class=n>requiredAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>requiredAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DrinkingLaw</span> <span class=n>canDrink</span><span class=p>(</span><span class=mi>18</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;I can drink: &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>canDrink</span><span class=p>(</span><span class=mi>20</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;Yup&#34;</span> <span class=o>:</span> <span class=s>&#34;Nope&#34;</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>Functors vs functions/methods:</strong></p><ul><li>Functors can contain state, since they’re just instances of a class<ul><li>Useful in cases where you want to calculate a running value of some kind</li></ul></li><li>Functors are way more customisable since you get them by calling the constructor, where you could pass in different arguments to get a functor that behaves differently</li></ul><a href=#lambda-functions-anonymous-functors><h3 id=lambda-functions-anonymous-functors><span class=hanchor arialabel=Anchor># </span>Lambda Functions (Anonymous Functors):</h3></a><p>You can think of lambda functions as syntactic sugar for <em>inline</em>, <em>anonymous functors</em>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>[</span><span class=n>_</span><span class=p>]</span> <span class=p>(</span><span class=n>params</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>RetType</span>    <span class=c1>// You can omit the return type if it can be implicitly inferred
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Function body
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>You can use the capture clause (the <code>[]</code> of the expression) to access variables from the outer scope<ul><li><code>[&foo, bar]</code> — capture foo by reference and bar by value</li><li><code>[&]</code> — capture all variables by reference<ul><li><code>[&, foo]</code> — capture all variables by reference apart from <code>foo</code></li></ul></li><li><code>[=]</code> — capture all variables by value<ul><li>[=, &foo] — capture all variables by value apart from <code>foo</code></li></ul></li></ul></li></ul><p>Lambda functions are great for concise, localised customisation of <em>predicate functions</em> (which are functions which given inputs, returns true/false).</p><p>A classic use of lambda functions is passing it as the comparator function to <code>std::sort</code> to define the the ordering of the sorted collection.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>c</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>c</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=o>**</span><span class=p>[[]]</span> <span class=p>{</span><span class=o>**</span>
</span></span><span class=line><span class=cl>    <span class=o>**</span><span class=k>return</span> <span class=n>a</span><span class=p>.</span><span class=n>key</span> <span class=o>&lt;</span> <span class=n>b</span><span class=p>.</span><span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=o>**</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><a href=#classes-1><h2 id=classes-1><span class=hanchor arialabel=Anchor># </span>Classes</h2></a><p>A class has a set of public or private <em>members</em>, which can be variables, functions or subtypes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=k>class</span> <span class=nc>Human</span><span class=o>**</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=o>**</span><span class=k>public</span><span class=o>:**</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=k>static</span> <span class=n>string</span> <span class=n>scientific_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		
</span></span><span class=line><span class=cl>		<span class=c1>// **Default constructor**
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=o>**</span><span class=n>Human</span><span class=o>**</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>**</span><span class=n>Human</span><span class=o>**</span><span class=p>(</span><span class=kt>int</span> <span class=n>age</span><span class=p>,</span> <span class=n>string</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Static class variables must be initialised outside the class definition:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=n>Human</span><span class=o>::</span><span class=n>scientific_name</span> <span class=o>=</span> <span class=s>&#34;homo sapiens&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// **Allocating the object on the heap**
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Human</span><span class=o>*</span> <span class=n>me1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Human</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>me1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// **Allocating the object on the stack** (meaning there&#39;s not need to call delete)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>Human</span> <span class=n>me2</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=n>Human</span> <span class=n>me3</span><span class=p>{</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>};</span>     <span class=c1>// An equivalent way of instantiating a class
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>Human</span> <span class=n>me4</span><span class=p>;</span>                <span class=c1>// Implicitly calls the default constructor	
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#instantiating-classes-todo><h3 id=instantiating-classes-todo><span class=hanchor arialabel=Anchor># </span>Instantiating Classes: [TODO]</h3></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocated on the stack 
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f1</span><span class=p>;</span>              <span class=c1>// Implicitly calls the default constructor Foo()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f2</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>     <span class=c1>// Copy initialisation
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>Foo</span> <span class=n>f3</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>          <span class=c1>// TODO:
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>Foo</span> <span class=n>f4</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>           <span class=c1>// Direct initialisation
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>Foo</span> <span class=n>f5</span><span class=p>{</span><span class=mi>1</span><span class=p>};</span>           <span class=c1>// List initialisation      (Generally preferred, unless **auto** is used)
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>Foo</span> <span class=n>f6</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>};</span>        <span class=c1>// TODO:
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=n>Foo</span> <span class=n>f7</span><span class=p>();</span>            <span class=c1>// You&#39;d think this is calling the default constructor, but it&#39;s not. See &#39;[most vexing parse](https://en.wikipedia.org/wiki/Most_vexing_parse)&#39;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocated on the heap (avoid when posssible)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=o>*</span> <span class=n>f8</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>f8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>General Guidelines for Choosing the Initialisation Method
<a href=https://stackoverflow.com/questions/9976927/when-to-use-the-brace-enclosed-initializer rel=noopener>*</a>:</strong></p><ul><li>Use <code>=</code> if the (single) value you are initialising with is intended to be the <em>exact value</em> of the object<ul><li>Prefer using <code>=</code> when assigning to <code>auto</code> variables</li><li>Prefer when initialising variables with primitive types (eg. int, bool, float, etc.)</li></ul></li><li>Use <code>{ }</code> if the values you are initialising with are a list of values to be <em>stored in the object</em> (like the elements of a vector/array, or real/imaginary part of a complex number)<ul><li>Prefer using { } in the majority of cases because it can be used in every context and is less error-prone than the alternatives</li></ul></li><li>Use <code>( )</code> if the values you are initialising with are <em>not</em> values to be stored, but <em>describe</em> the intended value/state of the object, use parentheses<ul><li><p>Essentially, if the intent is to call a particular constructor, then use parentheses <code>( )</code></p></li><li><p>Eg. good example with <code>vector</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>**</span><span class=n>v</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=o>**</span><span class=p>;</span>          <span class=c1>// Empty vector of 10 elements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>   <span class=c1>// Prints **10**
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>**</span><span class=n>u</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span><span class=o>**</span><span class=p>;</span>     <span class=c1>// Vector with elements 1, 2, 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>u</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>   <span class=c1>// Prints **3**
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><p><a href=https://stackoverflow.com/questions/18222926/why-is-list-initialization-using-curly-braces-better-than-the-alternatives rel=noopener>There are MANY reasons to use brace initialization, but you should be aware that <strong>the <code>initializer_list&lt;></code> constructor is preferred to the other constructors</strong>, the exception being the default-constructor. This leads to problems with constructors and templates where the type <code>T</code> constructor can be either an initializer list or a plain old ctor.</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=n>Foo</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;initializer list&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;copy ctor&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>b</span><span class=p>(</span><span class=n>a</span><span class=p>);</span> <span class=c1>// copy ctor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>c</span><span class=p>{</span><span class=n>a</span><span class=p>};</span> <span class=c1>// copy ctor (init. list element) + initializer list!!!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Assuming you don&rsquo;t encounter such classes there is little reason not to use the intializer list.</p><ul><li>Ways to construct an object<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Foo</span> <span class=n>f</span><span class=p>;</span>            <span class=c1>// Just calls Foo&#39;s default constructor, **Foo()**. In Java/C#, this would be an uninitialised object, but in C++ it has implicitly called the default constructor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Foo</span> <span class=n>f</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>    <span class=c1>// **Copy initialisation**:   calls Foo(), *then the **copy constructor***
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Foo</span> <span class=n>f</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>		<span class=c1>// Direct initialisation							
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Foo</span> <span class=nf>f</span><span class=p>();</span>           <span class=c1>// **Direct initialisation**: calls Foo()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>^</span><span class=n>WARNING</span> <span class=n>This</span> <span class=n>doesn</span><span class=err>&#39;</span><span class=n>t</span> <span class=k>do</span> <span class=n>what</span> <span class=n>you</span> <span class=n>think</span> <span class=n>it</span> <span class=n>does</span><span class=p>.</span> <span class=n>This</span> <span class=n>is</span> <span class=n>actually</span> <span class=n>interpreted</span> <span class=n>as</span> <span class=n>a</span> <span class=n>function</span> <span class=n>prototype</span><span class=p>.</span> <span class=n>What</span> <span class=n>you</span> <span class=n>want</span> <span class=n>is</span> <span class=n>just</span> <span class=o>**</span><span class=n>Foo</span> <span class=n>f</span><span class=p>;</span><span class=o>**</span> <span class=n>which</span> <span class=n>just</span> <span class=n>invokes</span> <span class=n>the</span> <span class=k>default</span> <span class=n>constructor</span> 
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#oop><h3 id=oop><span class=hanchor arialabel=Anchor># </span>OOP:</h3></a><ul><li><p><em><strong>Operator overloading</strong></em> — lets you define what operators like <code>++</code>, <code>[ ]</code>, <code>()</code>, etc. do when used on an instance of your class.</p><p>The compiler converts something like <code>a != b</code> to a function call <code>operator!=(a, b)</code></p><ul><li><p>Example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>Human</span><span class=p>(</span><span class=kt>int</span> <span class=n>age</span><span class=p>,</span> <span class=n>string</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>-&gt;</span><span class=n>age</span> <span class=o>=</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Defines the subscript operator []&#39;s behaviour. Returns a reference to the age property, regardless of the index (which is pretty dumb)
</span></span></span><span class=line><span class=cl><span class=c1></span>				<span class=c1>// Eg. **me[123]** will evalute to **this-&gt;age**
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span><span class=o>&amp;</span> <span class=o>**</span><span class=k>operator</span><span class=p>[]</span><span class=o>**</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>age</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>				<span class=c1>// Defines the *prefix* incrementor operator ++&#39;s behaviour. It just increases the age
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>void</span> <span class=o>**</span><span class=k>operator</span><span class=o>++**</span><span class=p>()</span> <span class=p>{</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>age</span><span class=o>++</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Human</span> <span class=n>me</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>me</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>me</span><span class=p>[</span><span class=mi>42</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>     <span class=c1>// Prints 21
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><em><strong>Destructors</strong></em></p><p>A method that&rsquo;s called when the object goes out of scope. It&rsquo;s main purpose is to ensure memory allocated resources on the heap are freed to prevent memory leaks.</p><ul><li><p>Example</p><p>You define a destructor the same way you define a constructor, except you prefix the classname with <code>~</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp></code></pre></td></tr></table></div></div></li></ul></li><li><p><strong>Virtual methods</strong> — a function that has an implementation but which may be redefined later by a class deriving from this one</p><ul><li><p><em><strong>Pure virtual method</strong></em> — where a function <em><strong>must</strong></em> be defined by a class deriving from this one</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=k>virtual</span> <span class=kt>void</span> <span class=n>Bar</span><span class=p>()</span> <span class=o>**=</span> <span class=mi>0</span><span class=o>**</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><em><strong>Abstract class</strong></em> — a class that has at least 1 <em>pure virtual method</em>. It cannot be instantiated</p><ul><li>C++ doesn&rsquo;t have an <code>abstract</code> keyword like Java. To make a class abstract, you just define 1 pure virtual method</li></ul></li><li><p><em><strong>Concrete class</strong></em> — a class that has no <em>pure virtual functions</em> and can be directly instantiated</p></li><li><p><code>override</code> keyword — is an <em>optional</em> qualifier that tells programmers that a method is meant to provide a definition for a virtual method from a base class</p></li><li><p>Any class with virtual functions should always provide a virtual <em>destructor</em></p></li></ul></li><li><p><strong>Inheritance [TODO]</strong></p></li><li><p>Polymorphism [TODO]</p><p>I think you can only access polymorphic objects through pointers and references</p></li></ul><hr><a href=#misc><h3 id=misc><span class=hanchor arialabel=Anchor># </span>Misc:</h3></a><ul><li><p><code>const</code> methods</p><aside>💡 Methods that don't modify object state should be declared `const`. See this [const-correctness article](http://www.gotw.ca/gotw/006.htm)</aside><p>When you add the <code>const</code> keyword to a method the <code>this</code> pointer will essentially become a pointer to <code>*const</code> object*, and you cannot therefore change any member data (unless you use <code>mutable</code> for class fields).</p><p>Declaring a method with <code>const</code> will cause a compiler error to be raised for when that method attempts to change a class variable.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=o>**</span><span class=kt>void</span> <span class=n>myConstFunction</span><span class=p>()</span> <span class=k>const</span><span class=o>**</span> <span class=p>{</span>       
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Overriden&#34;</span><span class=p>;</span>         <span class=c1>// Compiler error!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>You can add the <code>mutable</code> keyword to allow exceptions for what class variables can be modified by const member functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=p>...</span>
</span></span><span class=line><span class=cl>  <span class=n>Student</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Constructor&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>**</span><span class=kt>void</span> <span class=nf>myConstFunction</span><span class=p>()</span> <span class=k>const</span><span class=o>**</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Overriden&#34;</span><span class=p>;</span>       <span class=c1>// This is now fine ✓
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=o>**</span><span class=k>mutable</span><span class=o>**</span> <span class=n>string</span> <span class=n>name</span><span class=p>;</span>              <span class=c1>// Permit `name` to be mutated by const member functions 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>const</code> objects</p><p>An object declared with <code>const</code> means that mutating its fields is not allowed. You can&rsquo;t set class variables directly and you can&rsquo;t call methods that set class variables either.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Student</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Andrew&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setName</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Student</span> <span class=n>s1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>s1</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Taylor&#34;</span><span class=p>;</span>     <span class=c1>// ✓
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=o>**</span><span class=k>const</span> <span class=n>Student</span> <span class=n>s2</span><span class=o>**</span><span class=p>;</span>        
</span></span><span class=line><span class=cl>    <span class=n>s2</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Taylor&#34;</span><span class=p>;</span>     <span class=c1>// ✘ not fine because this modifies a class variable
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s2</span><span class=p>.</span><span class=n>setName</span><span class=p>(</span><span class=s>&#34;Taylor&#34;</span><span class=p>);</span>   <span class=c1>// ✘ not fine because this modifies a class variable
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>final</code> methods</p><p>Postfixing a method signature with the <code>final</code> keyword will make it so that it cannot be implemented by a deriving class.</p><ul><li><a href=https://stackoverflow.com/questions/8824587/what-is-the-purpose-of-the-final-keyword-in-c11-for-functions rel=noopener>Why final exists</a></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=err>**</span><span class=nc>BaseFoo</span><span class=o>**</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Info</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=err>**</span><span class=nc>Foo</span><span class=o>**</span> <span class=o>:</span> <span class=k>public</span> <span class=o>**</span><span class=n>BaseFoo</span><span class=o>**</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Info</span><span class=p>()</span> <span class=k>override</span> <span class=k>final</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=err>**</span><span class=nc>DerivingFoo</span><span class=o>**</span> <span class=o>:</span> <span class=k>public</span> <span class=o>**</span><span class=n>Foo</span><span class=o>**</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Info</span><span class=p>()</span> <span class=k>override</span> <span class=p>{}</span>            <span class=c1>// **Error**: cannot override **final** funtion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><code>explicit</code> methods</p><p>You can put explicit in front of constructors or methods to prevent implicit type conversions from other types to your class.</p><ul><li>It’s good practice to make constructors explicit by default, unless an implicit conversion makes sense semantically.
<a href=https://stackoverflow.com/questions/3716453/is-it-a-good-practice-to-make-constructor-explicit rel=noopener>Source</a></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=o>**</span><span class=n>MyVector</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span><span class=o>**</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>size</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>Show</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>size</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>MyVector</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>      <span class=c1>// Without an **explicit** constructor, this actually calls **MyVector(2)**. 
</span></span></span><span class=line><span class=cl><span class=c1></span>											 <span class=c1>// When you define **`explicit MyVector(int num)`**, this call would cause an error.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>v</span><span class=p>.</span><span class=n>print</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Access modifiers — <code>public</code>, <code>private</code>, <code>protected</code></p><p><code>public</code> — members are visible and usable anywhere in the program</p><p><code>private</code> — members are visible and usable only within the class itself and to <em>friend classes</em></p><p><code>protected</code> — like <em>private,</em> but derived classes are also allowed to access the members</p></li><li><p><em><strong>Member initialiser list</strong> —</em> for &lsquo;properly&rsquo; initialising class variables in the constructor [TODO]</p><aside>⚠️ This is not to be confused with **list initialisation**!</aside><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// **Member initialiser list**
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span><span class=o>**:</span> <span class=n>bar</span><span class=p>(</span><span class=n>num</span><span class=p>)</span><span class=o>**</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// **Simple assignment**
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>bar</span> <span class=o>=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>There is a significant difference between initialising a class variable with member initialiser list and simple assignment in the constructor body</p><ul><li>Member initialiser list — the constructor for each member will be called and initialised in one operation</li><li>Simple assignment in the body<ul><li>There is the additional overhead of creation <em>and</em> assignment when you do this</li><li>You can&rsquo;t initialise <code>const</code> class variables this way</li></ul></li></ul><hr><ul><li>Class members are initialised in the <strong>order that they are declared in the class</strong>, not the order they appear in the actual member initialiser list<ul><li>It&rsquo;s good practice to keep the order of class variable declarations and the order they appear in member initialiser lists the same</li></ul></li></ul></li><li><p><code>friend</code> — granting full internal access to other classes and functions</p><p>A class can declare who their <em>friends</em> are in their body. Friends are then able to access everything within that class, including private members.</p><ul><li><p>You can only declare who’s allowed to access you, not who you can have access to. Eg. in real life, you can’t grant yourself access to someone else’s privates, but you can grant others access to yours 😏</p></li><li><p>You can declare other classes or standalone functions as your friends</p></li><li><p>Example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Baby</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Baby</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=o>**</span><span class=k>friend</span> <span class=k>class</span> <span class=nc>Mother</span><span class=p>;</span><span class=o>**</span>        <span class=c1>// Makes it so that methods of **Mother** will be able to see everything in **Baby**
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Mother</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mother</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>babyName</span><span class=p>)</span> <span class=o>:</span> <span class=n>baby</span><span class=p>(</span><span class=n>babyName</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>RenameBaby</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>newName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>**</span><span class=n>baby</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>newName</span><span class=p>;</span><span class=o>**</span>    <span class=c1>// This is only possible because of `**friend class Mother**`
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Baby</span> <span class=n>baby</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Mother</span> <span class=n>mum</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mum</span><span class=p>.</span><span class=n>RenameBaby</span><span class=p>(</span><span class=s>&#34;Andy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p><strong>Use cases:</strong></p><ul><li>When you want to write white-box unit tests, then you can declare the unit test class as a friend. It’s good for unit testing private methods<ul><li>It’s
<a href=https://stackoverflow.com/questions/4171310/what-is-wrong-with-making-a-unit-test-a-friend-of-the-class-it-is-testing/4171331#4171331 rel=noopener>debatable</a> whether it’s good practice to test private methods. Testing a public method will indirectly test a private method anyway</li></ul></li></ul></li><li><p>Class prototypes</p><p>Class prototypes: just like function prototypes, you can declare all your classes upfront and then use them wherever you want throughout the code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Declare my classes
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Define my classes (any order will do)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>C</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Remeber, <em>hoisting</em> does not exist in C++</li></ul></li><li><p><em>Deleted</em> <em>functions</em> (<code>= delete</code>)</p><p>Just like how you can use <code>= 0</code> to declare a function to be a pure virtual function, you can use <code>= delete</code> to declare a function to be a <em>delete function</em>.</p><p>A <em>delete function</em> is one that has been explicitly disabled. It’s useful for disabling certain operators from being usable on your class, for example. Any attempts to call a deleted function raises a compile-time error.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>Bar</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span> <span class=o>&amp;</span><span class=p>)</span> <span class=o>**=</span> <span class=k>delete</span><span class=o>**</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><hr><ul><li>In general, prefer allocating on the stack rather than the heap, unless you need the object to persist after the function terminates<ul><li>When allocating on the heap, you have to explicitly call <code>delete</code> on that object to prevent memory leaks. Making the caller responsible for remembering to call <code>delete</code> themselves is bad practice<ul><li>Every <code>new</code> must have a corresponding <code>delete</code>, just like how every <code>malloc(...)</code> must have a corresponding <code>free(...)</code> in C</li><li>With stack-allocated objects, the destructor is automatically called when the scope ends</li></ul></li><li>Allocating on the heap is less performant than allocating on the stack<ul><li><strong>The stack is faster</strong> because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in an allocation or free
<a href=https://stackoverflow.com/questions/24057331/is-accessing-data-in-the-heap-faster-than-from-the-stack rel=noopener>*</a></li></ul></li><li>Very large objects should still be on the heap to prevent stack overflow (the heap is larger than the stack)</li></ul></li><li>Note: In Java/C#, you can’t allocate objects on the stack, they’d all be allocated on the heap. You could use a <code>struct</code> instead</li></ul><a href=#enums><h2 id=enums><span class=hanchor arialabel=Anchor># </span>Enums</h2></a><p>In addition to structs and classes, you can also use enums to declare new data types. Enums are used to represent small sets of integer values in a readable way.</p><p>There are two kinds of enums in C++, <em>plain enums</em> and <em>enum classes</em> (which are preferred over plain enums because of their type safety).</p><ul><li><p><strong>Plain Enum:</strong>
Declared with just <code>enum</code>. The enum&rsquo;s values can be implicitly converted to integers</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=k>enum</span> <span class=nc>Mood</span><span class=o>**</span> <span class=p>{</span> <span class=n>happy</span><span class=p>,</span> <span class=n>sad</span><span class=p>,</span> <span class=n>nihilistic</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>Mood</span> <span class=n>currMood</span> <span class=o>=</span> <span class=n>Mood</span><span class=o>::</span><span class=n>happy</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>currMood</span><span class=p>;</span>           <span class=c1>// No error, the **Mood** value is implicitly converted to an integer type
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p><strong>Enum Classes:</strong>
When you declare an enum with <code>enum class</code>, it is strongly typed such that you won&rsquo;t be able to assign an enum value to an integer variable or to another enum type. It reduces the number of &lsquo;surprises&rsquo; which is why it&rsquo;s preferred</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=k>enum</span> <span class=k>class</span> <span class=nc>Mood</span><span class=o>**</span> <span class=p>{</span> <span class=n>happy</span><span class=p>,</span> <span class=n>sad</span><span class=p>,</span> <span class=n>nihilistic</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>Mood</span> <span class=n>currMood</span> <span class=o>=</span> <span class=n>Mood</span><span class=o>::</span><span class=n>happy</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>currMood</span><span class=p>;</span>            <span class=c1>// Error, **Mood::happy** is not an **int**
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#modules-todo><h2 id=modules-todo><span class=hanchor arialabel=Anchor># </span>Modules [TODO]</h2></a><p>This looks like a C++20 feature, which isn&rsquo;t really out yet (at least not stably in Nov 2021).</p><a href=#using-todo><h3 id=using-todo><span class=hanchor arialabel=Anchor># </span>Using [TODO]</h3></a><p><code>using</code> keyword — what are all the uses of it?</p><ul><li><p>question: are there performance impacts to this?</p></li><li><p>Can be used for type aliasing instead of typedef</p><ul><li>It’s generally more preferred to use <code>using</code> over C-style <code>typedef</code>. It also supports a little more extra functionality that is not available with <code>typedef</code>
<a href=https://stackoverflow.com/questions/10747810/what-is-the-difference-between-typedef-and-using-in-c11 rel=noopener>Source</a></li></ul></li><li><p>Can be used to inherit constructors:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span> <span class=o>:</span> <span class=k>public</span> <span class=n>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>C</span><span class=o>::</span><span class=n>C</span><span class=p>;</span>  <span class=c1>// inherit all constructors from C
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>NewMethod</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Is using namespace std; bad practice?</p><ul><li>It&rsquo;s bad because it pollutes your namespace with lots of new identifiers that could collide with whatever identifiers you try to bring in. Your code could be silently calling the wrong function for instance</li><li>using namespace should never be used in header files because it forces the consumer of the header file to also bring in all those identifiers into their namespaces</li><li>You can always do <code>using std::cout</code> so that you don&rsquo;t have to always type <code>std::cout</code></li></ul></li><li><p><a href=https://stackoverflow.com/questions/1106149/what-is-a-translation-unit-in-c rel=noopener>Translation units</a> (basically just a c or cpp file <em>after</em> it&rsquo;s finished including all of the header files)</p></li></ul><a href=#exception-handling-todo><h3 id=exception-handling-todo><span class=hanchor arialabel=Anchor># </span>Exception Handling [TODO]</h3></a><ul><li>Exception handling<ul><li>And the built-in exception types that C++ defines in
<a href=https://en.cppreference.com/w/cpp/header/stdexcept rel=noopener>stdexcept</a></li></ul></li></ul><a href=#asserts-todo><h3 id=asserts-todo><span class=hanchor arialabel=Anchor># </span>Asserts [TODO]</h3></a><ul><li><code>assert</code> and <code>static_assert</code> (runtime vs compile time assertions)</li></ul><a href=#casts-todo><h3 id=casts-todo><span class=hanchor arialabel=Anchor># </span>Casts [TODO]</h3></a><ul><li>static_cast and const_cast and dynamic_cast and regular C-style casting</li></ul><a href=#initializer-list-todo><h3 id=initializer-list-todo><span class=hanchor arialabel=Anchor># </span>Initializer List [TODO]</h3></a><ul><li><p><code>std::initializer_list&lt;T></code> — seems like it allows an object to be initialised using curly brace syntax and has</p><p>NOT TO BE CONFUSED WITH ‘Member initialiser lists’ used in constructors to initialise its fields.</p><p>Apparently, an instance of std::initializer_list&lt;&mldr;> is automatically constructed when:</p><ol><li><p>{} is used to construct a new object: <code>Person person{"Tim", "Zhang"}</code></p><ul><li>Note: I think it’s a bit confusing. From experimentation, this will call the constructor of signature <code>Person(std::initializer_list&lt;string> l) {...}</code> if it exists. Else it will look for <code>Person(string firstName, string lastName) { ... }</code>.</li></ul></li><li><p>{} is used on the RHS of an assignment.</p><ul><li>Note: I think this will look for the = operator (assignment) overload method that takes in an instance of <code>std::initializer_list</code> and call that.</li></ul></li><li><p>{} is bound to auto. Eg.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=p>{</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span> <span class=p>})</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><p>Note: <code>std::initializer_list</code> is an iterable.</p><p>For some reason, you cannot subscript an instance of std::initializer_list like you would a vector or array (
<a href=https://stackoverflow.com/questions/17787394/why-doesnt-stdinitializer-list-provide-a-subscript-operator rel=noopener>SO discussion</a>). It seems that it’s just not a desired enough use case?</p><p><a href=https://www.cplusplus.com/reference/initializer_list/initializer_list/ rel=noopener>**Notes from cplusplus.com</a>:**</p><p>The compiler automatically converts { &mldr; } to objects of type std::initializer_list. For example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=n>il</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>20</span><span class=p>,</span> <span class=mi>30</span> <span class=p>};</span>  <span class=c1>// the type of il is an initializer_list
</span></span></span></code></pre></td></tr></table></div></div><p>Constructors taking only one argument of this type are a special kind of constructor, called <em>initializer-list constructor</em>. Initializer-list constructors take precedence over other constructors when the initializer-list constructor syntax is used:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>myclass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=n>myclass</span> <span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	  <span class=n>myclass</span> <span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	  <span class=cm>/* definitions ... */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>myclass</span> <span class=n>foo</span> <span class=p>{</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>};</span>  <span class=c1>// calls initializer_list ctor
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>myclass</span> <span class=nf>bar</span> <span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>);</span>  <span class=c1>// calls first constructor
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>constructor initialiser list (member initialiser list) — the list of stuff that follows the colon : in a constructor implementation.</p><ul><li>Call base class constructors here</li><li>Initialise member variables before the constructor body executes (const members MUST be initialised this way, you can’t set them in the body)</li></ul></li></ul><a href=#extern-todo><h3 id=extern-todo><span class=hanchor arialabel=Anchor># </span>Extern [TODO]</h3></a><ul><li><code>extern</code> keyword<ul><li><a href=https://stackoverflow.com/questions/10422034/when-to-use-extern-in-c rel=noopener>Good explanation</a></li><li><code>extern int x;</code> tells the compiler that an object of type <code>int</code> called <code>x</code> exists <em>somewhere</em>. It&rsquo;s not the compilers job to know where it exists, it just needs to know the type and name so it knows how to use it. Once all of the source files have been compiled, the linker will resolve all of the references of <code>x</code> to the one definition that it finds in one of the compiled source files. For it to work, the definition of the <code>x</code> variable needs to have what&rsquo;s called “external linkage”, which basically means that it needs to be declared outside of a function (at what&rsquo;s usually called “the file scope”) and without the <code>static</code> keyword.</li></ul></li></ul><a href=#volatile-todo><h3 id=volatile-todo><span class=hanchor arialabel=Anchor># </span>Volatile [TODO]</h3></a><ul><li><code>volatile</code> keyword</li></ul><a href=#decltype-todo><h3 id=decltype-todo><span class=hanchor arialabel=Anchor># </span>Decltype [TODO]</h3></a><ul><li><code>decltype</code> keyword</li></ul><a href=#templates><h3 id=templates><span class=hanchor arialabel=Anchor># </span>Templates</h3></a><ul><li><p>Templates</p><ul><li>They’re quite similar to generics in managed languages like Java or C#, but they’re much more powerful. A template is basically you getting the compiler to write code for you, based on a couple rules.<ul><li>You can kind of think of template functions as things that are created on demand — kind of like a code generator. If there are no calls to it, then it actually doesn’t exist after compilation. You could leave syntax errors inside template functions that aren’t called and the compiler just ignores them entirely (but this is compiler-dependent)!</li><li>Some companies literally ban the use of templates in their source code. It’s because overusing templates can make the code very unreadable. There’s a delicate tradeoff between having to do manual, repetitive coding and accessing the powerful abstracted-away code-generation magic that templates offer</li><li><em>Metaprogramming</em> is basically about when a program has knowledge of itself and can manipulate itself.<ul><li>C#’s reflection feature is a form of metaprogramming (where it can examine its own static types)</li><li>C++ gives us template metaprogramming, where the templates you program are used by the compiler to generate more source code.</li></ul></li></ul></li></ul></li><li><p>Copy elision — the compiler is ‘<em>allowed</em>’ to <em>elide</em> copies where results are “as if” copies were made. Ie. the compiler can decide to skip the copy/move construction of an object. Return value optimisation (RVO) is one such instance.</p><ul><li>Note: in English/linguistics, to <em>elide</em> means to merge and therefore omit something in language. Eg. dunno == don’t know, kinda == kind of, etc</li><li>It’s an optimisation technique implemented by most C++ compilers to prevent extraneous copy operations. It is because of copy elision that return-by-value and pass-by-value usually remain quite performant in C++ (assuming the certain criteria to allow for it are met).</li><li>Calls to the copy or move constructors can be entirely skipped!</li></ul></li><li><p>Wtf can curly braces be used for?</p><ul><li><p>Defining anonymous scope blocks</p><ul><li>Yep, wrote notes on this</li></ul></li><li><p>Initialising arrays and vectors, and possibly other objects?</p><ul><li>Yep. It’s generally preferred. You wrote notes on this</li></ul></li><li><p>Constructor initialiser lists</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Vector</span><span class=o>::</span><span class=n>Vector</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>)</span> <span class=o>:</span><span class=n>elements</span><span class=p>{</span><span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>s</span><span class=p>]},</span> <span class=n>capacity</span><span class=p>{</span><span class=n>s</span><span class=p>}</span> <span class=p>{</span> <span class=p>...</span><span class=n>constructor</span> <span class=n>body</span><span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ^
</span></span></span><span class=line><span class=cl><span class=c1>// According to https://stackoverflow.com/questions/36212837/member-initializer-list-notation-curly-braces-vs-parentheses
</span></span></span><span class=line><span class=cl><span class=c1>// this is pretty much equivalent to:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector</span><span class=o>::</span><span class=n>Vector</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>)</span> <span class=o>:</span><span class=n>elements</span><span class=p>(</span><span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>s</span><span class=p>]),</span> <span class=n>capacity</span><span class=p>(</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span><span class=n>constructor</span> <span class=n>body</span><span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Google&#39;s style guide&#39;s section on constructor initialiser lists shows examples with parentheses instead of curly braces 
</span></span></span><span class=line><span class=cl><span class=c1>// Scott Meyer in &#39;Effective Modern C++&#39;: There’s no consensus that either approach is better than the other, so my advice is to pick one and apply it consistently.
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>Delegating constructors</p><ul><li>You can call other constructors from a constructor in the initialiser list. Doing this however means you can’t use a member initialiser list</li><li>You cannot call constructors from the body of another constructor ☹️</li><li>Often, you’d have to resort to defining a SharedInit() method</li></ul></li></ul><p>Constructors and assignments for copy or move semantics:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>X</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>X</span><span class=p>(</span><span class=n>Sometype</span><span class=p>);</span>            <span class=c1>// &#39;Ordinary constructor&#39; for creating an object
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>X</span><span class=p>();</span>                    <span class=c1>// Default constructor
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>X</span><span class=p>(</span><span class=k>const</span> <span class=n>X</span> <span class=o>&amp;</span><span class=p>);</span>           <span class=c1>// Copy constructor. Takes in a const l-value reference
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>X</span><span class=p>(</span><span class=n>X</span> <span class=o>&amp;&amp;</span><span class=p>);</span>                <span class=c1>// Move constructor. Takes in an r-value reference
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>		<span class=n>X</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>X</span><span class=o>&amp;</span><span class=p>);</span> <span class=c1>// Copy assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>X</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>X</span><span class=o>&amp;&amp;</span><span class=p>);</span>      <span class=c1>// Move assignment
</span></span></span><span class=line><span class=cl><span class=c1></span>		
</span></span><span class=line><span class=cl>		<span class=o>~</span><span class=n>X</span><span class=p>();</span>                   
</span></span><span class=line><span class=cl>		<span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Switch-case statements in C++ are a bit different. They’re like this? (They have curly braces around the cases)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>tag</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>2</span><span class=o>:</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>3</span><span class=o>:</span> <span class=p>{</span>  
</span></span><span class=line><span class=cl>        <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Iterators</p><ul><li><p>It’s up to the implementation to define what iteration means. It’s kind of like operator overloading, you could make the ++ operator do literally anything.</p><ul><li>To support range-based for loops, your class has to implement the <code>begin()</code> and <code>end()</code> methods and make them return an iterator</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>values</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Equivalently
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=n>it</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Syntactic sugar for the above
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>value</span> <span class=p>:</span> <span class=n>values</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>end() isn’t the last element, it’s one beyond the last element, meaning it’s an invalid iterator</li><li>Should you always use range-based for loops?<ul><li>In general yes, but with exceptions. Eg. you should not use it when you are erasing values, inserting something into the middle of something, etc., basically anytime you need to manipulate the position of the iterator, you’d have to fall back to the ugly for loop.</li></ul></li></ul></li><li><p>Looping with indexes vs iterators</p><ul><li>Indexes work for arrays, vectors, etc. but for other data structures like sets, you have no choice but to use iterators .</li></ul></li><li><p>const_iterator is for read-only iteration — making sure you don’t mutate the collection.</p></li><li><p>When mutating a container, you must keep in mind that changing the container has an impact on existing iterators that point at elements in the container.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// BUGGY CODE, DO NOT USE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>c</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=k>if</span> <span class=p>(</span><span class=n>BadValue</span><span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=n>c</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Although this seems simple enough, there is a fatal flaw: erasing an element in an associative container invalidates all iterators that point to that element. Thus, in the above <code>for</code>loops continuation step, the iterator <code>it</code> will be invalid whenever <code>c.erase(it)</code> was just invoked, resulting in undefined behaviour. To remedy this issue, we can leverage the post-increment operator like so:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>c</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>BadValue</span><span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>c</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=o>++</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>This time, our loop behaves as expected. While <code>it</code> is incremented before calling <code>erase</code>, the post-increment operator returns the previous (unincremented) value, which is then passed to <code>erase</code>. For <code>vector</code>s, <code>deque</code>s, and <code>list</code>s, we can leverage the fact that <code>erase</code> returns an iterator that points at the next value in the container and write:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>c</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=k>if</span> <span class=p>(</span><span class=n>BadValue</span><span class=p>(</span><span class=o>*</span><span class=n>it</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=n>it</span> <span class=o>=</span> <span class=n>c</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>it</span><span class=p>);</span>
</span></span><span class=line><span class=cl>	  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		    <span class=o>++</span><span class=n>it</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><code>#include</code> tells the preprocessor to copy the contents of the included file and directly paste it into the current file, that’s literally all that happens.</p><ul><li><code>#include &lt;path></code><ul><li>With <code>&lt;></code>, the preprocessor searches for the thing to include in directories defined by the compiler. You would use &lt;> often for including standard library headers</li><li>On Linux, you can find all the libraries stored on the path <code>/usr/include/c++/&lt;version_num></code></li></ul></li><li><code>#include “path”</code><ul><li>With <code>“”</code>, the preprocessor searches first in the same directory as the file first, and then searches through the same directories that <code>#include &lt;path></code> would search through</li></ul></li></ul></li><li><p>Header guards are used inside header files to ensure that the contents of the file are not copied and pasted more than once to any single file. They have the form:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef YOUR_HEADER_NAME_H
</span></span></span><span class=line><span class=cl><span class=cp>#define YOUR_HEADER_NAME_H
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>The entire purpose of namespaces is to avoid naming conflicts (and as a logical container for classes, further namespaces, etc.)</p></li><li><p>About std::swap:</p><ul><li>Often, <code>std::swap(T& a, T& b)</code> is horribly inefficient because it could involve copies or moves three times</li></ul></li><li><p>Constexpr methods — declared with the <code>constexpr</code> qualifier</p><ul><li>Constexpr methods are also implicitly <code>inline</code> methods</li><li>Can be used to initialise constants at compile time</li></ul></li><li><p>What is external linkage?
<a href="https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage#:~:text=External-linkage-refers-to-things,units-%28or-object-files%29" rel=noopener>https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage#:~:text=External linkage refers to things,units (or object files)</a>.</p><ul><li>Linkage has to do with how many instances (or copies) of a named object there are in a program. it is usually best for a constant with one name to refer to a single object within the program.</li><li>When you write a .cc file, the compiler generates a translation unit from it. This is basically the source file, plus all the headers that you #included.<ul><li>Internal linkage refers to everything <strong>only in scope of a translation unit</strong></li><li>External linkage refers to things that exist beyond a particular translation unit. Ie. accessible through the whole program, which is the combination of al translation units</li></ul></li></ul></li><li><p>You can do namespace aliases to shorten namespaces. Never do this in header files</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>testing</span> <span class=o>=</span> <span class=o>::</span><span class=n>my</span><span class=o>::</span><span class=n>testing</span><span class=o>::</span><span class=n>framework</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>TODO: Copy over the stuff in the cheatsheet that are missing in this set of notes</p><ul><li>Eg. bitsets, <code>&lt;algorithm></code> functions, etc.</li></ul></li><li><p>Still can’t fully understand <code>const</code>.</p><ul><li>I think I’m really confused with combinations of qualifiers: static, const, constexpr in a class definition and outside of it, and whether you can initialise the member/variable when declared or if it must be defined in the .cc file.
Could list out all possibilities.</li></ul></li><li><p>regular array literal vs using std::array</p></li><li><p><a href="https://www.google.com/search?q=references+as+members&oq=references+as+members&aqs=chrome..69i57.4024j0j7&sourceid=chrome&ie=UTF-8" rel=noopener>https://www.google.com/search?q=references+as+members&oq=references+as+members&aqs=chrome..69i57.4024j0j7&sourceid=chrome&ie=UTF-8</a></p></li></ul><a href=#templates-1><h2 id=templates-1><span class=hanchor arialabel=Anchor># </span><strong>Templates:</strong></h2></a><ul><li><p>Templates vs. generics [TODO]</p><p>Templates are massively different from generics like in Java.</p><p>In Java, generics are mainly syntactic sugar that help programmers avoid boilerplate casting code.</p><p>Some main differences that developers should know:</p><ul><li><p>Java doesn’t let you pass primitive types like <code>int</code> as type parameters&mldr; yup. You can’t do this</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>ArrayList</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>myList</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div></li></ul></li></ul><p><a href="https://www.youtube.com/watch?v=LMP_sxOaz6g&ab_channel=CppCon" rel=noopener>CppCon talk</a></p><a href=#function-templates><h3 id=function-templates><span class=hanchor arialabel=Anchor># </span>Function Templates:</h3></a><p>Suppose you’re writing multiple overloads for a method, and each overload does essentially the same thing but just takes in different types.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=o>**</span><span class=n>swap</span><span class=o>**</span><span class=p>(</span><span class=kt>int</span><span class=o>&amp;</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=kt>int</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>i</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>j</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>**</span><span class=n>swap</span><span class=o>**</span><span class=p>(</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s1</span><span class=p>,</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>s2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=n>string</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>s1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>s1</span> <span class=o>=</span> <span class=n>s2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>s2</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><p>Clearly there’s a lot of duplicated code in each overload, and this approach would not scale well in practice. A solution to this is to use <em><strong>function templates</strong></em> to define a generalised algorithm and let the compiler generate all the overloads for you on compilation.</p><ul><li>Strictly speaking, a function template is not really a function. It’s a generalisation of an algorithm that is used as a tool by the compiler for generating similar but distinct functions.<ul><li>The act of generating a function from a function template by the compiler is called <em><strong>template instantiation</strong></em></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>**</span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;**</span>      <span class=c1>// Start of T&#39;s scope
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>****</span><span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>		<span class=n>T</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>                          <span class=c1>// End of T&#39;s scope
</span></span></span></code></pre></td></tr></table></div></div><p><code>T</code> is a <em><strong>type argument</strong></em>. Its scope is limited to the function body.</p><ul><li><p>Using <code>class</code> instead of <code>typename</code></p><p>You can also use the <code>class</code> keyword instead of <code>typename</code>. The behaviour is exactly the same in template definitions&mldr; there’s historical reasons why they’re interchangeable.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>  <span class=n>is</span> <span class=n>the</span> <span class=n>same</span> <span class=n>as</span>  <span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>They both have <em>very</em> different meanings in different contexts though.</p></li></ul><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/Untitled.png width=auto alt=Untitled></p><p>When you invoke <code>**swap&lt;int>(i, j)**</code>, the compiler will <em>instantiate</em> a function with signature <code>**void swap&lt;int>(int& a, int& b)**</code> for you by plugging in the types into the template function you defined. Template instantiation is done on-demand when you compile.</p><ul><li>The compiler is smart enough to avoid instantiating duplicate functions</li></ul><a href=#class-templates><h3 id=class-templates><span class=hanchor arialabel=Anchor># </span>Class Templates:</h3></a><p>Much like how a function template is a generalisation of an algorithm, a class template is a generalisation of a type, <em>but it’s not an actual type</em>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyContainer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>		<span class=n>MyContainer</span><span class=p>(</span><span class=n>T</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// In member implementations *done outside of the class*, you must fully qualify with the prefix `MyContainer&lt;T&gt;::`.
</span></span></span><span class=line><span class=cl><span class=c1>// Anything following :: will adopt the class&#39; scope, meaning that specifying &lt;T&gt; becomes optional again. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>MyContainer</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>MyContainer</span><span class=p>(</span><span class=n>T</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Note: when in the scope of the class body, you can use <code>MyContainer</code> and <code>MyContainer&lt;T></code> interchangeably. Essentially, you can consider <code>&lt;T></code> optional inside the class body. However, when outside the class, you have to fully qualify the name with <code>MyContainer&lt;T>::</code><ul><li><p>Once you specify <code>MyContainer&lt;T>::</code>, you can imagine that you’re basically re-entering the class scope, and then everything you could access within the class become available again.</p><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/Untitled%201.png width=auto alt=Untitled></p></li></ul></li></ul><p><strong>Container Class Templates:</strong></p><p>A container is an object that contains other objects. Examples include arrays, linked lists, etc.</p><p>The standard C++ library provides various container class templates like:</p><ul><li><code>list&lt;T></code></li><li><code>vector&lt;T></code></li><li><code>set&lt;T></code></li></ul><p>TODO: should learn more about move semantics. Specifically copy and move constructors as well as std::move</p><a href=#c-appendix><h1 id=c-appendix><span class=hanchor arialabel=Anchor># </span>C++ Appendix:</h1></a><p>All the notes under this section are meant to be topics or details you don’t need to care much about to program effectively with C++ but which are important background information.</p><a href=#how-c-compilation-works><h3 id=how-c-compilation-works><span class=hanchor arialabel=Anchor># </span>How C++ Compilation Works:</h3></a><p>Compilation of C++ programs follow 3 steps:</p><ol><li><p><strong>Preprocessing</strong></p><p>Preprocessor directives like <code>#include</code>, <code>#define</code>, <code>#if</code>, etc. transforms the code before any compilation happens. At the end of this step, a pure C++ file is produced.</p></li><li><p><strong>Compilation</strong></p><p>The compiler (eg. g++, the GNU C++ compiler) takes in pure C++ source code and produces an object file. This step doesn’t produce anyting that the user can actually run — it just produces the machine language instructions.</p></li><li><p><strong>Linking</strong></p><p>Takes object files and produces a library or executable file that your OS can use.</p></li></ol><a href=#curly-braces-in-c><h3 id=curly-braces-in-c><span class=hanchor arialabel=Anchor># </span>Curly Braces in C++:</h3></a><p>This section exists because I keep seeing curly braces appearing in different contexts and having totally different semantics.</p><ul><li><p>Defining <em><strong>scope blocks</strong></em></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//***CODE****
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=c1>// A smaller scope containing some statements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//****MORE CODE****
</span></span></span></code></pre></td></tr></table></div></div><ul><li>Doing this within a function is useful when you want a destructor to be called as soon as possible. Eg. often when dealing with mutexes, you’d want to acquire and release a lock as soon as possible.</li></ul></li><li></li></ul><a href=#union><h3 id=union><span class=hanchor arialabel=Anchor># </span>Union:</h3></a><p>A <code>union</code> is data structure like a <code>class</code> or <code>struct</code>, except all its members share the same memory address, meaning it can only hold 1 value for one member at a time. The implication is that a union can only hold <strong>one value at a time</strong>, and its total allocated memory is equal to $\texttt{max(sizeof each member)}$.</p><ul><li>It’s mainly used when you really need to conserve memory</li><li>They’re largely useless in C++ and more useful in C</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>union</span> <span class=nc>Numeric</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span>  <span class=n>sVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>    <span class=n>iVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>dVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Unions&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Numeric</span> <span class=n>num</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>42</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>.</span><span class=n>sVal</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// Prints **42**
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>.</span><span class=n>iVal</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// Prints **42**
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>.</span><span class=n>dVal</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// Interprets the bits of 42 using floating point representation (IEEE 754)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#struct><h3 id=struct><span class=hanchor arialabel=Anchor># </span>Struct:</h3></a><ul><li><strong>Structs vs. Classes:</strong> There are very few differences between a <code>struct</code> and a <code>class</code> in C++.<table><thead><tr><th>Struct</th><th>Class</th></tr></thead><tbody><tr><td>Members are public by default</td><td>Members are private by default</td></tr><tr><td>Are value types</td><td>Are reference types</td></tr></tbody></table></li><li><strong>Structs in C vs. C++</strong><table><thead><tr><th>C</th><th>C++</th></tr></thead><tbody><tr><td>Can only have fields</td><td>Can have methods and fields</td></tr><tr><td>No class features</td><td>Has constructors, inheritance, private/protected/public members, literally everything you expect in a class</td></tr></tbody></table></li><li>You should use structs when you need a plain-old-data structure that doesn’t require any class-like features
<a href=https://stackoverflow.com/questions/54585/when-should-you-use-a-class-vs-a-struct-in-c rel=noopener>*</a></li></ul><a href=#structured-binding><h3 id=structured-binding><span class=hanchor arialabel=Anchor># </span>Structured Binding:</h3></a><p><strong>Structured binding</strong> is syntactic sugar for declaring variables initialised with items/fields of a data structure.</p><ul><li>JavaScript calls this <em><strong>destructuring</strong></em>, Python calls this <em>unpacking</em>, C# calls this <em>deconstructing</em></li><li>Unfortunately, you have to specify as many identifiers as there are things to unpack</li></ul><p><strong>Use Cases:</strong></p><ul><li><p>Array destructuring</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=p>[</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>]</span> <span class=o>=</span> <span class=n>arr</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Ranged for-loop</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;World&#34;</span><span class=p>,</span> <span class=mi>24</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=o>**</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>key</span><span class=p>,</span> <span class=n>val</span><span class=p>]</span><span class=o>**</span> <span class=o>:</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Key: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>key</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, val: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Class/struct destructuring</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Foo</span> <span class=nf>f</span><span class=p>(</span><span class=mi>42</span><span class=p>,</span> <span class=mi>24</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=p>[</span><span class=n>u</span><span class=p>,</span> <span class=n>v</span><span class=p>]</span> <span class=o>=</span> <span class=n>f</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Tuple destructuring</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>tup</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=mf>3.14</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=p>[</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>]</span> <span class=o>=</span> <span class=n>tup</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>Continue at 5.2 in Tour of C++</p><a href=#c-primer><h1 id=c-primer><span class=hanchor arialabel=Anchor># </span>C++ Primer:</h1></a><ul><li><p>Any variable with the following properties will be placed into <em>static memory</em>:</p><ul><li>Declared with <code>static</code></li><li>Has namespace scope</li></ul><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/Untitled%2010.png width=auto alt=Untitled></p></li><li><p>Variable with <em>static storage duration</em> have their address and size known at compile time. They’ll live for as long as the program lifetime.</p></li><li><p>There is a <code>thread_local</code> keyword in C++. When a variable is declared with <code>thread_local</code>, it is brought into existence when the thread starts and deallocated when the thread ends. In that sense, the thread sees it as a <em>static storage duration</em> variable.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>thread_local</span> <span class=kt>int</span> <span class=n>myInt</span> <span class=o>=</span> <span class=p>...;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>Continue at ‘RAII (The &ldquo;Resource Acquisition Is Initialization&rdquo; Idiom)’</p><a href=#c-style><h1 id=c-style><span class=hanchor arialabel=Anchor># </span>C++ Style</h1></a><a href=#style-guide><h3 id=style-guide><span class=hanchor arialabel=Anchor># </span>Style Guide</h3></a><p><a href=https://google.github.io/styleguide/cppguide.html rel=noopener>Google C++ Style Guide</a></p><p>Note: there are many decisions in the Google C++ style guide that many people protest against, for example, the lack of exceptions. It generally has good style rules otherwise.</p><a href=#soruce-code-documentation><h3 id=soruce-code-documentation><span class=hanchor arialabel=Anchor># </span>Soruce Code Documentation</h3></a><p>The advice here is sourced from
<a href=https://google.github.io/styleguide/cppguide.html rel=noopener>Google’s C++ style guide</a>.</p><p><strong>File Comments</strong></p><p>File comments are preferred but not always necessary. Function and class documentation, on the other hand, must be present with exceptions only for trivial cases.</p><ul><li>Start with licence boilerplate, then broadly describe what abstractions are introduced by the file.</li><li>Don’t duplicate comments across a class’ <code>.h</code> and <code>.cc</code> file.</li></ul><p><a href=https://github.com/google/googletest/blob/main/googletest/src/gtest-all.cc rel=noopener>Example</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Copyright 2008, Google Inc.
</span></span></span><span class=line><span class=cl><span class=c1>// All rights reserved.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Redistribution and use in source and binary forms, with or without
</span></span></span><span class=line><span class=cl><span class=c1>// modification, are permitted
</span></span></span><span class=line><span class=cl><span class=c1>// ... and so on
</span></span></span><span class=line><span class=cl><span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1>// Google C++ Testing and Mocking Framework (Google Test)
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Sometimes it&#39;s desirable to build Google Test by compiling a single file.
</span></span></span><span class=line><span class=cl><span class=c1>// This file serves this purpose.
</span></span></span></code></pre></td></tr></table></div></div><p><strong>Variable comments</strong></p><p>Generally not required if the name is sufficiently descriptive. Often for class variables, more context is needed to explain the purpose of the variable.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	 <span class=c1>// Used to bounds-check table accesses. -1 means
</span></span></span><span class=line><span class=cl><span class=c1></span>	 <span class=c1>// that we don&#39;t yet know how many entries the table has.
</span></span></span><span class=line><span class=cl><span class=c1></span>	 <span class=kt>int</span> <span class=n>num_total_entries_</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>TODO comments</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// TODO(kl@gmail.com): Use a &#34;*&#34; here for concatenation operator.
</span></span></span><span class=line><span class=cl><span class=c1>// TODO(Zeke) change this to use relations.
</span></span></span><span class=line><span class=cl><span class=c1>// TODO(bug 12345): remove the &#34;Last visitors&#34; feature.
</span></span></span></code></pre></td></tr></table></div></div><p><strong>Function comments</strong></p><p>Always write a comment to explain what the function/method accomplishes unless it is trivial. This includes private functions.</p><ul><li>Start with a verb. Eg. “Opens a file&mldr;” or “Returns an iterator for&mldr;”</li><li>Which arguments can be <code>nullptr</code> and what that would mean.</li><li>Performance implications of how the function is used.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Returns an iterator for this table, positioned at the first entry
</span></span></span><span class=line><span class=cl><span class=c1>// lexically greater than or equal to `start_word`. If there is no
</span></span></span><span class=line><span class=cl><span class=c1>// such entry, returns a null pointer. The client must not use the
</span></span></span><span class=line><span class=cl><span class=c1>// iterator after the underlying GargantuanTable has been destroyed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// This method is equivalent to:
</span></span></span><span class=line><span class=cl><span class=c1>//    std::unique_ptr&lt;Iterator&gt; iter = table-&gt;NewIterator();
</span></span></span><span class=line><span class=cl><span class=c1>//    iter-&gt;Seek(start_word);
</span></span></span><span class=line><span class=cl><span class=c1>//    return iter;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Iterator</span><span class=o>&gt;</span> <span class=n>GetIterator</span><span class=p>(</span><span class=n>absl</span><span class=o>::</span><span class=n>string_view</span> <span class=n>start_word</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>Class comments</strong></p><p>Always write a comment to explain what the class’ purpose is and when to correctly use it. Always do this in the <code>.h</code> file, leaving comments about implementation detail to the implementing <code>.cc</code> file.</p><ul><li><p>Good place to provide a code snippet illustrating a simple use case.</p></li><li><p>About documenting the <code>.h</code> header file vs. documenting the <code>.cc</code> source file</p><ul><li>Document how to use the function in the header file, or more accurately close to the declaration</li><li>Document how the function works (if it&rsquo;s not obvious from the code) in the source file, or more accurately, close to the definition</li></ul><p><a href=https://softwareengineering.stackexchange.com/questions/84071/is-it-better-to-document-functions-in-the-header-file-or-the-source-file rel=noopener>Source</a>.</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Iterates over the contents of a GargantuanTable.
</span></span></span><span class=line><span class=cl><span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1>// Example:
</span></span></span><span class=line><span class=cl><span class=c1>//    std::unique_ptr&lt;GargantuanTableIterator&gt; iter = table-&gt;NewIterator();
</span></span></span><span class=line><span class=cl><span class=c1>//    for (iter-&gt;Seek(&#34;foo&#34;); !iter-&gt;done(); iter-&gt;Next()) {
</span></span></span><span class=line><span class=cl><span class=c1>//        process(iter-&gt;key(), iter-&gt;value());
</span></span></span><span class=line><span class=cl><span class=c1>//    }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>GargantuanTableIterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#abseil><h1 id=abseil><span class=hanchor arialabel=Anchor># </span>Abseil:</h1></a><p>Basically Google’s standard library</p><p><a href=https://abseil.io/ rel=noopener>https://abseil.io/</a></p><p><a href=/Knowledge/Engineering/Languages/C++-Cheatsheet rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++-Cheatsheet>Knowledge/Engineering/Languages/C++ Cheatsheet</a></p><a href=#flashcards><h1 id=flashcards><span class=hanchor arialabel=Anchor># </span>Flashcards</h1></a><ul><li>What is separate compilation?<ul><li>A division of a larger project into smaller units that interact with each other through header files. One unit only knows about another unit through their header files. The big benefit of structuring projects this way is to allow for compilation to be done independently on these units, meaning that if one unit changes while others have not, then only that one unit is to be compiled.</li></ul></li><li>What are the differences between copy, list and direct initialisation?<ul><li>They&rsquo;re the 3 ways initialisation of a new variable is done in C++. Copy initialisation is done with <code>=</code>, list initialisation is done with <code>{}</code>, and direct initialisation is done with <code>()</code>. Copy initialisation invokes the . Direct initialisation is directly invoking the constructor, hence the use of <code>()</code>.</li></ul></li><li>What is the difference between <code>const</code> and <code>constexpr</code>?</li><li>What happens when an identifier is declared outside of a namespace?<ul><li>That identifier becomes globally scoped, i.e. part of the global namespace. It can be referenced directly or with <code>::</code> to explicitly say it&rsquo;s from the global namespace.</li></ul></li><li>Explain RAII and what problem it aims to solve.<ul><li><em>Resource allocation is initialisation</em> means that any resources (things like file handles, database handles, etc.) required by a class should be acquired in the constructor and then released in the destructor. Think of it as &ldquo;scope-bound resource management&rdquo;. The point here is that when a class throws an exception or goes out of scope, the destructor is called, guaranteeing no resources to be held after the object&rsquo;s lifetime.</li></ul></li><li>What are designated initialisers in C++? How do you use them?</li><li>How do you define a custom exception in C++?<ul><li>Write a new class that inherits from <code>std::exception</code> and implement the <code>const char* what() const throw()</code> method and implement a constructor that takes in an error message.</li></ul></li><li>Explain copy elision.</li><li>What problem does a move constructor solve — when would you use one?</li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/ data-ctx=C++ data-src=/ class=internal-link>Tim's Dev Wiki</a></li><li><a href=/Knowledge/Engineering/Languages/Go/ data-ctx=C++ data-src=/Knowledge/Engineering/Languages/Go class=internal-link>Go</a></li><li><a href=/Knowledge/Engineering/Programming/AOT/ data-ctx=C++ data-src=/Knowledge/Engineering/Programming/AOT class=internal-link>AOT</a></li><li><a href=/Knowledge/Engineering/Programming/Object-Oriented-Programming/ data-ctx="pure virtual function" data-src=/Knowledge/Engineering/Programming/Object-Oriented-Programming class=internal-link>Object Oriented Programming</a></li></ul></div></div><div id=contact_buttons><footer><ul><li><a href=/>Home</a></li><li><a href=https://timz.dev>timz.dev</a></li><li><a href=https://github.com/Tymotex/wiki>Github</a></li><li><a href=https://www.linkedin.com/in/timz-seng>LinkedIn</a></li></ul><p>Tim Zhang © 2022</p></footer></div></div></body></html>