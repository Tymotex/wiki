<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="![[Knowledge/Engineering/Languages/assets/cpp-wallpaper.png|800]]
C++ is a [[Knowledge/Engineering/Programming/Type System#Static Typing|statically-typed]], low-level programming language that supports [[Knowledge/Engineering/Programming/Object Oriented Programming|object-oriented programming]]. It&rsquo;s frequently used in any software system that requires resource efficiency such as operating systems, game engines, databases, compilers, etc."><title>C++</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://wiki.timz.dev//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://wiki.timz.dev/styles.f0166864fd6bb1603db547f1f970f84b.min.css rel=stylesheet><link href=https://wiki.timz.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://wiki.timz.dev/js/darkmode.773d76aedcd615c64f644f542d60cb1b.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://wiki.timz.dev/js/popover.688c5dcb89a57776d7f1cbeaf6f7c44b.min.js></script>
<script src=https://wiki.timz.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://wiki.timz.dev/js/clipboard.de8d8b2221fe27323078cbd76188e364.min.js></script>
<script>const BASE_URL="https://wiki.timz.dev/",fetchData=Promise.all([fetch("https://wiki.timz.dev/indices/linkIndex.c61e9e87d84697c9de0ce10162aaa488.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://wiki.timz.dev/indices/contentIndex.32a30cb8edb8fe01314a46b4f23e8a25.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://wiki.timz.dev",t,[{"/Knowledge/Engineering":"#4388cc"},{"/Knowledge/Investing":"#98c379"},{"/Knowledge/Personal-Finance":"#98c379"},{"/Knowledge/Finance":"#FFD700"},{"/Knowledge/Economics":"#FFD700"}],t?{centerForce:1,depth:3,enableDrag:!0,enableLegend:!0,enableZoom:!0,fontSize:.4,linkDistance:1,opacityScale:3,repelForce:.2,scale:1.4}:{centerForce:1,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:1,scale:3}),initPopover("https://wiki.timz.dev",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://wiki.timz.dev/js/search.cf33b507388f3dfd5513a2afcda7af41.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://wiki.timz.dev/js/graph.0ac96ed5ea296a8b1ac03a6eba11878c.js></script><div class=singlePage><header><h1 id=page-title><a href=https://wiki.timz.dev/>ðŸŒ± Tim's Dev Wiki</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>C++</h1><p class=meta>Last updated December 27, 2022.</p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#copy-list-and-direct-initialisation>Copy, List and Direct Initialisation</a><ol><li></li></ol></li><li><a href=#pointers-and-references>Pointers and References</a><ol><li><a href=#pointers>Pointers</a></li><li><a href=#references>References</a></li></ol></li><li><a href=#new>new</a><ol><li><a href=#delete>delete</a></li></ol></li><li><a href=#type-qualifiers-auto-const-constexpr-static>Type Qualifiers: auto, const, constexpr, static</a><ol><li><a href=#auto>Auto</a></li><li><a href=#const>Const</a></li><li><a href=#constexpr>Constexpr</a></li><li><a href=#static>Static</a></li><li><a href=#clockwise-spiral-rule>Clockwise-Spiral Rule</a></li></ol></li><li><a href=#io>IO</a></li><li><a href=#arrays>Arrays</a><ol><li><a href=#pointers-vs-arrays>Pointers vs. Arrays</a></li></ol></li><li><a href=#l-values-and-r-values>L-Values and R-Values</a><ol><li><a href=#l-value-reference>L-Value Reference</a></li><li><a href=#r-value-reference>R-Value Reference</a></li></ol></li><li><a href=#modularity>Modularity</a><ol><li><a href=#separate-compilation>Separate Compilation</a></li><li><a href=#namespaces>Namespaces</a></li></ol></li><li><a href=#error-handling>Error Handling</a><ol><li><a href=#custom-exceptions>Custom Exceptions</a></li><li><a href=#noexcept>noexcept</a></li></ol></li><li><a href=#classes>Classes</a><ol><li><a href=#inheritance>Inheritance</a></li><li><a href=#member-initialiser-list-and-delegating-constructors>Member Initialiser List and Delegating Constructors</a></li><li><a href=#virtual-methods>Virtual Methods</a></li><li><a href=#object-slicing>Object Slicing</a></li><li><a href=#instantiating-classes>Instantiating Classes</a></li><li><a href=#const-objects>Const Objects</a></li><li><a href=#final-methods>Final Methods</a></li><li><a href=#explicit-methods>Explicit Methods</a></li><li><a href=#friend-classes>Friend Classes</a></li><li><a href=#deleted-functions>Deleted Functions</a></li><li><a href=#defaulted-functions>Defaulted Functions</a></li><li><a href=#raii>RAII</a></li><li><a href=#operator-overloading>Operator Overloading</a></li><li><a href=#copy-constructor-and-operation>Copy Constructor and Operation</a></li><li><a href=#move-constructor-and-operation>Move Constructor and Operation</a></li></ol></li><li><a href=#templates>Templates</a><ol><li><a href=#templates-vs-generics>Templates vs. Generics</a></li><li><a href=#function-templates>Function Templates</a></li><li><a href=#class-templates>Class Templates</a></li><li><a href=#aliases>Aliases</a></li><li><a href=#concepts-todo>Concepts [TODO]</a></li><li><a href=#type-traits-todo>Type Traits [TODO]</a></li><li><a href=#deduction-guides-todo>Deduction Guides [TODO]</a></li></ol></li><li><a href=#functors>Functors</a><ol><li><a href=#lambda-functions>Lambda Functions</a></li></ol></li><li><a href=#enums>Enums</a><ol><li><a href=#plain-enum>Plain Enum</a></li><li><a href=#enum-class>Enum Class</a></li><li><a href=#initialiser-list>Initialiser List</a></li><li><a href=#iterators>Iterators</a></li></ol></li><li><a href=#random-c-features>Random C++ Features</a><ol><li><a href=#structured-bindings>Structured Bindings</a></li><li><a href=#using>Using</a></li><li><a href=#copy-elision>Copy Elision</a></li><li><a href=#return-type-deduction>Return Type Deduction</a></li><li><a href=#initialiser-list-1>Initialiser List</a></li><li><a href=#casting-todo>Casting [TODO]</a></li><li><a href=#inline-functions>Inline Functions</a></li><li><a href=#if-statement-with-initialiser>if-statement With Initialiser</a></li><li><a href=#noexcept-conditions>Noexcept Conditions</a></li><li><a href=#aggregates>Aggregates</a></li><li><a href=#protected-and-private-inheritance>Protected and Private Inheritance</a></li><li><a href=#class-prototypes>Class Prototypes</a></li><li><a href=#user-defined-literals>User-Defined Literals</a></li><li><a href=#thread_local>thread_local</a></li><li><a href=#unnamed-scopes>Unnamed Scopes</a></li><li><a href=#union>Union</a></li><li><a href=#compile-time-if-todo>Compile-Time If [TODO]</a></li><li><a href=#volatile-todo>Volatile [TODO]</a></li><li><a href=#extern>Extern</a></li><li><a href=#fold-expressions-todo>Fold Expressions [TODO]</a></li></ol></li></ol><ol><li><ol><li><a href=#c-compilation-todo>C++ Compilation [TODO]</a></li><li><a href=#commenting>Commenting</a></li></ol></li></ol><ol><li><a href=#questions>Questions</a></li></ol></nav></details></aside><p><img src=/Knowledge/Engineering/Languages/assets/cpp-wallpaper.png width=800></p><p>C++ is a <a href=/Knowledge/Engineering/Programming/Type-System#static-typing rel=noopener class=internal-link data-src=/Knowledge/Engineering/Programming/Type-System>statically-typed</a>, low-level programming language that supports <a href=/Knowledge/Engineering/Programming/Object-Oriented-Programming rel=noopener class=internal-link data-src=/Knowledge/Engineering/Programming/Object-Oriented-Programming>object-oriented programming</a>. It&rsquo;s frequently used in any software system that requires resource efficiency such as operating systems, game engines, databases, compilers, etc.</p><p>C/C++&rsquo;s high performance is attributed to how closely it&rsquo;s constructs and operations match the hardware.</p><p>The <strong><a href=https://isocpp.org/std/-the-standard rel=noopener>ISO C++ standard</a></strong> defines:</p><ul><li>Core language features â€” data types, loops, etc.</li><li>Standard library components â€” <code>vector</code>, <code>map</code>, <code>string</code>, etc.</li></ul><p>Also see <a href=/Knowledge/Engineering/Languages/C++-Standard-Library rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++-Standard-Library>C++ standard library</a>.</p><a href=#basics><h1 id=basics><span class=hanchor arialabel=Anchor># </span>Basics</h1></a><a href=#copy-list-and-direct-initialisation><h2 id=copy-list-and-direct-initialisation><span class=hanchor arialabel=Anchor># </span>Copy, List and Direct Initialisation</h2></a><p>There are a few ways to initialise a variable with a value.</p><ol><li><strong>Copy initialisation</strong>: using <code>=</code>. It implicitly calls a constructor.</li><li><strong>List initialisation</strong>, also called <strong>uniform initialisation</strong>: using <code>{ }</code>.</li><li><strong>Direct initialisation</strong>: using <code>( )</code>. Think of the parentheses as being used to <em>directly</em> invoke a specific constructor.</li></ol><blockquote><p>Prefer uniform initialisation over copy initialisation.</p></blockquote><pre><code>```cpp
int b(1);     // Direct initialisation.
int a{1};     // List initialisation.
int c = 1;    // Copy initialisation.
int d = {1};  // Copy/List initialisation.
```
</code></pre><ul><li><em>List initialisation</em> does not allow <em>narrowing</em>. Try to use list initialisation <code>{ }</code> more often.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mf>7.8</span><span class=p>;</span>  <span class=c1>// Gets floored to 7
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>i</span><span class=p>{</span><span class=mf>7.8</span><span class=p>};</span>   <span class=c1>// Error: narrowing conversion from &#39;double&#39; to &#39;int&#39;
</span></span></span></code></pre></td></tr></table></div></div></li><li><code>explicit</code> constructors are <em>not invokable</em> with copy initialisation.</li></ul><a href=#designated-initialisers><h4 id=designated-initialisers><span class=hanchor arialabel=Anchor># </span>Designated Initialisers</h4></a><p>C++20 introduces a new way to initialise the members of a class/struct:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Human</span> <span class=n>andrew</span><span class=p>{</span> <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Andrew&#34;</span><span class=p>,</span> <span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>42</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Human</span> <span class=n>linus</span><span class=p>{</span> <span class=p>.</span><span class=n>name</span><span class=p>{</span><span class=s>&#34;Linus&#34;</span><span class=p>}</span> <span class=p>};</span>               <span class=c1>// You can also use list initialisation on the members.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>Human</span> <span class=n>ada</span><span class=p>{</span> <span class=p>.</span><span class=n>age</span> <span class=o>=</span> <span class=mi>36</span><span class=p>,</span> <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Ada&#34;</span> <span class=p>};</span>       <span class=c1>// Error. You must initialise the fields in the same order as they&#39;re declared in the struct/class.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#pointers-and-references><h2 id=pointers-and-references><span class=hanchor arialabel=Anchor># </span>Pointers and References</h2></a><p>Pointers and references are really the same thing under the hood, however they have different semantics to the programmer. You can consider references as syntactic sugar for pointers whose main purpose is to help you write cleaner code, compared to if you were to use pointers for the same use case.</p><blockquote><p>Unlike other languages, in C++, arguments <em><strong>are always passed by value
<a href=https://www.learncpp.com/cpp-tutorial/passing-arguments-by-value rel=noopener>by default</a></strong></em> <em>unless the function signature explicitly says it takes in a pointer or reference</em>. This means functions will <strong>entirely copy</strong> all the objects you pass in, unless you pass in a pointer/reference.</p></blockquote><blockquote><p><code>*</code> and <code>&</code> have different meanings depending on whether they appear in a type declaration (LHS) or whether they appear in an expression that is to be evaluated (RHS).</p></blockquote><p>In a <em>type</em> <em>declaration</em>:</p><ul><li><code>*</code> defines a <strong>pointer type</strong>. <code>int* arr;</code></li><li><code>&</code> defines a <strong>reference variable</strong>.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>ref</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>In an <em>expression</em>:</p><ul><li><code>*</code> is the unary <strong>dereference</strong> <strong>operator</strong> that dereferences an address to evaluate to the contents at that address.</li><li><code>&</code> is the unary <strong>address-of operator</strong> that evaluates to the address of a variable. <code>&</code> always expects an <a href=/Knowledge/Engineering/Languages/C++#l-values-and-r-values rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>lvalue</a>.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>&amp;</span><span class=n>i</span>         <span class=c1>// â†’ Eg. 0x7FFEF2BA1884
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>&amp;&amp;</span><span class=n>i</span>        <span class=c1>// â†’ Illegal operation. &amp;(0x7FFEF2BA1884) doesn&#39;t make sense.
</span></span></span></code></pre></td></tr></table></div></div></li></ul><a href=#pointers><h3 id=pointers><span class=hanchor arialabel=Anchor># </span>Pointers</h3></a><p>Pointers are just memory addresses, often to the contents of an object allocated on the heap.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>q</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>=</span> <span class=n>q</span><span class=p>;</span>          <span class=c1>// p now contains the memory address of y.
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/pointers-illustrated.png width=590 alt="illustration of pointers|590"></p><ul><li><code>nullptr</code>. C++ requires that <code>NULL</code> is a constant that has value <code>0</code>. Unlike in C, <code>NULL</code> cannot be defined as <code>(void *)</code><ul><li><code>nullptr</code> therefore exists to distinguish between 0 and an <em>actual null</em> for pointer types. People would otherwise mistakenly use <code>NULL</code> and not realise it is just 0</li></ul></li><li><strong>Note</strong>:
<a href=https://stackoverflow.com/questions/6990726/correct-way-of-declaring-pointer-variables-in-c-c/6990753 rel=noopener>Stroustrup prefers</a> the pointer declaration style <code>int* p</code> in C++ and <code>int *p</code> in C.</li></ul><a href=#references><h3 id=references><span class=hanchor arialabel=Anchor># </span>References</h3></a><p>You can think of a reference variable as an alias for another variable. They donâ€™t occupy any memory themselves, once your program is compiled and running.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>y</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>r</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>&amp;</span> <span class=n>r2</span> <span class=o>=</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>r2</span><span class=p>;</span>      <span class=c1>// Remember, you can think of references as aliases. This assignment is basically just `x = y`
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/references-illustrated.png width=600 alt="illustration of references|600"></p><ul><li>References are useful as function parameters to avoid copying the entire argument. <strong>In C++, pass-by-value is the default</strong>, although <em>copy elision</em> can happen which nullifies the performance impact of making a copy of an object.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>sort</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>sequence</span><span class=p>);</span>    <span class=c1>// Will sort the given sequence, in-place.
</span></span></span></code></pre></td></tr></table></div></div></li><li>Const references are useful for when you don&rsquo;t want to modify an argument and <strong>just want to read its contents</strong>. It prevents the need to make a copy of that argument for the function&rsquo;s scope. This is really common practice:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>getAverage</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>sequence</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li>References must be initialised and canâ€™t be reassigned afterwards.</li><li>When you return a reference, you are &lsquo;<em>granting the caller access to something that isn&rsquo;t local to the function</em>&rsquo;. It is an error to return a reference to a local variable.</li></ul><a href=#new><h2 id=new><span class=hanchor arialabel=Anchor># </span>new</h2></a><p><code>new</code> is used to instantiate classes and arrays on the heap. All objects allocated with <code>new</code> must have a corresponding <code>delete</code> somewhere.</p><ul><li>You should
<a href=https://stackoverflow.com/questions/333443/c-object-instantiation rel=noopener>always prefer stack allocations</a> rather than heap allocations.<ul><li>This helps avoid memory leaks because when the variable is allocated for in the stack, its <em>destructor</em> is automatically called when leaving its scope</li></ul></li><li>It is generally better to avoid having to use <code>new</code> and <code>delete</code> in your code, or at least the code that&rsquo;s using your code shouldn&rsquo;t have to be responsible for memory management.</li><li>Prefer <code>new</code> and <code>delete</code> over C-style <code>malloc</code> and <code>free</code>. The reasons are: type safety (since <code>new</code> ensures instantiated objects are initialised), readability, <code>new</code> throws an exception on failure while <code>malloc</code> doesn&rsquo;t.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Human</span><span class=p>()</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Creating an object whose memory will be allocated on the heap.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Human</span><span class=o>*</span> <span class=n>me</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Human</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>me</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Creating an array whose memory will be allocated on the heap.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span><span class=o>*</span> <span class=n>A</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// This array will have its memory allocated on the stack, so no delete operation is necessary.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>B</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>             
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#delete><h3 id=delete><span class=hanchor arialabel=Anchor># </span>delete</h3></a><p>There are two delete operators, <code>delete</code> and <code>delete[]</code>.</p><ul><li><code>delete</code> â€” for individual objects. It calls the destructor of that single object.</li><li><code>delete[]</code> â€” for arrays. It calls the destructor on each object.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span><span class=o>*</span> <span class=n>courses</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span><span class=o>*</span> <span class=n>zId</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Student</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>courses</span> <span class=o>=</span> <span class=k>new</span> <span class=n>string</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>zId</span> <span class=o>=</span> <span class=k>new</span> <span class=n>string</span><span class=p>(</span><span class=s>&#34;z5258971&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>Student</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>courses</span><span class=p>;</span>       <span class=c1>// Deleting an array.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>zId</span><span class=p>;</span>             <span class=c1>// Deleting an individual string.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#type-qualifiers-auto-const-constexpr-static><h2 id=type-qualifiers-auto-const-constexpr-static><span class=hanchor arialabel=Anchor># </span>Type Qualifiers: auto, const, constexpr, static</h2></a><a href=#auto><h3 id=auto><span class=hanchor arialabel=Anchor># </span>Auto</h3></a><p>When specifying the data type of something as <code>auto</code>, C++ automatically infers the type.</p><ul><li>Use <code>auto</code> for concision, especially when long generic types are involved.</li><li>It&rsquo;s fine to use <a href=/Knowledge/Engineering/Languages/C++#variables rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>copy initialisation</a> if you use <code>auto</code> since type narrowing won&rsquo;t be a problem. E.g. <code>auto x = 1</code>.</li><li>Always assume that <code>auto</code>, by itself, will make a copy of the RHS. Use <code>auto&</code> if copying is undesirable (such as when copying large vectors).</li></ul><a href=#const><h3 id=const><span class=hanchor arialabel=Anchor># </span>Const</h3></a><p>The <code>const</code> qualifier makes it &lsquo;impossible&rsquo; to assign a new value to a variable after it&rsquo;s initialised. There is 0 negative performance impact of enforcing <code>const</code> since it&rsquo;s all done at compile-time. Using const can actually allow the compiler to make optimisations.</p><blockquote><p>Prefer making things const by default. See
<a href=https://isocpp.org/wiki/faq/const-correctness rel=noopener>const correctness</a> for a pitch on why.</p></blockquote><ul><li><code>const</code> and <code>constexpr</code>â€” immutable variables. Declaring and initialising a <code>const</code> variable will make the compiler guarantee that its value is never modified, ever.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>      
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>auto</span> <span class=n>j</span> <span class=p>{</span><span class=mi>2</span><span class=p>};</span>      <span class=c1>// You can put **const** before pretty much any variable declaration
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// With **const**, you can assign it a value that is determined during runtime.
</span></span></span><span class=line><span class=cl><span class=c1>// With **constexpr**, you can only assign it values known at compile-time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>8</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=n>cube</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>    <span class=c1>// Error, *unless cube is defined as a [**constexpr function**](https://www.ibm.com/docs/es/xl-c-and-cpp-aix/16.1?topic=functions-constexpr-c11)*
</span></span></span></code></pre></td></tr></table></div></div></li></ul><a href=#const-pointers><h4 id=const-pointers><span class=hanchor arialabel=Anchor># </span>Const Pointers</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>               <span class=c1>// A pointer to an immutable int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>q</span> <span class=o>=</span> <span class=p>...;</span>  <span class=c1>// An immutable pointer to an immutable int. It must be initialised with a memory address.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>r</span> <span class=o>=</span> <span class=p>...;</span>        <span class=c1>// An immutable pointer to an int. It must be initisalised with a memory address.
</span></span></span></code></pre></td></tr></table></div></div><p>If this is hard to read, see the <a href=/Knowledge/Engineering/Languages/C++#clockwise-spiral-rule rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>clockwise-spiral rule</a>.</p><a href=#const-references><h4 id=const-references><span class=hanchor arialabel=Anchor># </span>Const References</h4></a><p>Typing a variable as a const reference makes it a read-only alias. It&rsquo;s especially helpful for function parameters.</p><blockquote><p>Prefer typing function parameters as const references. This gives the caller confidence that what they pass in is not modified in any way.</p></blockquote><p>If you don&rsquo;t want a function to modify a caller&rsquo;s argument, you have these options:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo1</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>   <span class=c1>// Preferred approach.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo2</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>s</span><span class=p>);</span>   <span class=c1>// A pointer to a const also works.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>foo3</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>s</span><span class=p>);</span>          <span class=c1>// Since pass-by-value is the default, `s` is an independent copy of what the caller passed in.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// If you want a parameter to be modifiable:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>bar1</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>);</span>         <span class=c1>// This might modify the caller&#39;s string directly.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>bar1</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span><span class=o>*</span> <span class=n>s</span><span class=p>);</span>         <span class=c1>// So can this.
</span></span></span></code></pre></td></tr></table></div></div><p>You can&rsquo;t have 100% certainty that what you pass as a const reference is unchanged. See
<a href=https://isocpp.org/wiki/faq/const-correctness#return-const-ref-from-const-memfn rel=noopener>this example from isocpp</a>:</p><a href=#const-methods><h4 id=const-methods><span class=hanchor arialabel=Anchor># </span>Const Methods</h4></a><p>Const methods can only read <code>this</code> and never mutate any of its members. TheÂ <code>this</code>Â pointer will essentially become a pointer toÂ <code>const</code>Â object. To specify a const method, the <code>const</code> qualifier <em>must</em> be placed after the parameter list.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=n>my_const_func</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>       
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Overridden&#34;</span><span class=p>;</span>   <span class=c1>// Compiler error!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Methods that don&rsquo;t modify object state should be declared <code>const</code>. See this
<a href=http://www.gotw.ca/gotw/006.htm rel=noopener>const-correctness article</a></p></blockquote><blockquote><p>What about making methods <strong>return const values</strong>, eg. <code>const Foo bar();</code>?
<a href=https://stackoverflow.com/questions/8716330/purpose-of-returning-by-const-value rel=noopener>It&rsquo;s <em>mostly</em> pointless</a>. However, it is <em>not</em> pointless if you&rsquo;re returning a pointer or reference to something that is const.</p></blockquote><a href=#mutable><h5 id=mutable><span class=hanchor arialabel=Anchor># </span>Mutable</h5></a><p>Declaring a method with <code>const</code> will cause a compiler error to be raised for when that method attempts to change a class variable.</p><p>You can add the <code>mutable</code> keyword to allow an exception for what class variables can be modified by const member functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=n>myConstFunction</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Overridden&#34;</span><span class=p>;</span>       <span class=c1>// This is now fine âœ“.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>mutable</span> <span class=n>string</span> <span class=n>name</span><span class=p>;</span>              <span class=c1>// Permit `name` to be mutated by const member functions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#constexpr><h3 id=constexpr><span class=hanchor arialabel=Anchor># </span>Constexpr</h3></a><p>The <code>constexpr</code> type specifier is like <code>const</code>, except the RHS value must be able to be determined at compile-time.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>const</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=n>some_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#constexpr-functions><h4 id=constexpr-functions><span class=hanchor arialabel=Anchor># </span>Constexpr Functions</h4></a><p>Constexpr functions are those than <em>can</em> be executed at compile-time, meaning all its state and behaviour is determinable at compile-time.</p><a href=#static><h3 id=static><span class=hanchor arialabel=Anchor># </span>Static</h3></a><a href=#static-variables><h4 id=static-variables><span class=hanchor arialabel=Anchor># </span>Static Variables</h4></a><p>Inside functions, static variables let you share a value across all calls to that function.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>    <span class=c1>// All calls to **foo** will see **a = 42**.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>...</span>                   <span class=c1>// If **a** changes, then all calls to **foo** will see that change too
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Static function variables areÂ <strong>generally considered bad</strong>Â because they represent global state and are therefore much more difficult to reason about
<a href="https://stackoverflow.com/questions/7026507/why-are-static-variables-considered-evil#:~:text=Static-variables-are-generally-considered,assumptions-of-object%2Doriented-programming." rel=noopener>*</a>.</p></blockquote><a href=#clockwise-spiral-rule><h3 id=clockwise-spiral-rule><span class=hanchor arialabel=Anchor># </span>Clockwise-Spiral Rule</h3></a><p><a href=http://c-faq.com/decl/spiral.anderson.html rel=noopener>Clockwise-Spiral Rule</a> is a trick for reading variable types.</p><ol><li>Start at the variable name.</li><li>Follow an outwards clockwise spiral from that variable name to build up a sentence.</li></ol><p><strong>Example</strong>:
<img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/clockwise-spiral.png width=400 alt="clockwise-spiral rule example|400">
Starting at the name <code>fp</code>:</p><ol><li><code>fp</code> is a pointer.</li><li><code>fp</code> is a pointer to a function (that takes in an <code>int</code> and a <code>float</code> pointer).</li><li><code>fp</code> is a pointer to a function (that takes in an <code>int</code> and a <code>float</code> pointer) that returns a pointer.</li><li><code>fp</code> is a pointer to a function (that takes in an <code>int</code> and a <code>float</code> pointer) that returns a pointer to a char.</li></ol><p>More examples:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=n>myVar</span><span class=p>;</span>                     <span class=c1>// pointer to an int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>const</span> <span class=o>*</span><span class=n>myVar</span><span class=p>;</span>               <span class=c1>// pointer to a const int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=o>*</span> <span class=k>const</span> <span class=n>myVar</span> <span class=o>=</span> <span class=p>...;</span>        <span class=c1>// const pointer to an int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=k>const</span> <span class=o>*</span> <span class=k>const</span> <span class=n>myVar</span> <span class=o>=</span> <span class=p>...;</span>  <span class=c1>// const pointer to a const int.
</span></span></span></code></pre></td></tr></table></div></div><a href=#io><h2 id=io><span class=hanchor arialabel=Anchor># </span>IO</h2></a><p><code>&lt;&lt;</code> â€” the <strong>&lsquo;put to&rsquo;</strong> operator. In <code>arg1 &lt;&lt; arg2</code>, the <code>&lt;&lt;</code> operator takes the second argument and writes it into the first.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Meaning of life: &#34;</span> <span class=o>&lt;&lt;</span> <span class=mi>42</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>>></code> â€” the <strong>&lsquo;get from&rsquo;</strong> operator. In <code>arg1 >> arg2</code>, the <code>>></code> operator gets a value from <code>arg1</code> and assigns it to <code>arg2</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>std::endl</code> is a newline that flushes the output buffer, which means it is less performant than <code>"\n"</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>             <span class=c1>// Adds a &#34;\n&#34; and flushes the output buffer.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>             <span class=c1>// Adds a &#34;\n&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>flush</span><span class=p>;</span>    <span class=c1>// Adds a &#34;\n&#34; and flushes the output buffer.
</span></span></span></code></pre></td></tr></table></div></div><p>See <a href=/Knowledge/Engineering/Languages/C++-Standard-Library#io rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++-Standard-Library>C++ Standard Library IO</a> for more complex IO operations.</p><a href=#arrays><h2 id=arrays><span class=hanchor arialabel=Anchor># </span>Arrays</h2></a><p>The many ways of initialising arrays:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>];</span>                    <span class=c1>// [?, ?, ?, ?] â€“ array is full of garbage values, often zeroes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  <span class=p>};</span>             <span class=c1>// [0, 0, 0, 0] â€“ all elements set to 0.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>   <span class=c1>// [1, 2, 3, 4].
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span>            <span class=c1>// [1, 0, 0, 0] â€“ the rest of array is zeroed.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>arr</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>    <span class=c1>// Array size can be omitted if it can be inferred from RHS.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>arr</span><span class=p>[]</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span> <span class=p>};</span>      <span class=c1>// You can use uniform initialisation instead of copy initialisation.
</span></span></span></code></pre></td></tr></table></div></div><p>The size of the array must be able to be determined at compile-time.</p><a href=#pointers-vs-arrays><h3 id=pointers-vs-arrays><span class=hanchor arialabel=Anchor># </span>Pointers vs. Arrays</h3></a><p>What&rsquo;s the difference between <code>int* array</code> and <code>int array[]</code>? They both can be used to access a sequence of data and are mostly interchangeable.</p><p>The main difference is in <strong>runtime allocation and resizing</strong>: <code>int* array</code> is far more flexible, allowing allocation/deallocation and resizing during runtime, whereas <code>int array[]</code> cannot be resized after declaration.</p><blockquote><p>In general, <em>prefer using declaring <strong>true array-types</strong> with <code>[]</code> over pointers-type arrays with <code>*</code></em>. It&rsquo;s less error-prone (because you don&rsquo;t have to worry about dynamic allocation and remembering to free allocated memory) and more readable.</p></blockquote><a href=#l-values-and-r-values><h2 id=l-values-and-r-values><span class=hanchor arialabel=Anchor># </span>L-Values and R-Values</h2></a><p>An <strong>lvalue</strong> is a memory location that identifies an object. <strong>Variables are lvalues</strong>.</p><blockquote><p>In C: an <em>lvalue</em> is an expression that can appear on the LHS <em><strong>or</strong></em> RHS of an assignment.</p></blockquote><p>An <strong>rvalue</strong> is a value stored at some memory address. Rvalues are different from lvalues in that <strong>they cannot have a value assigned to it</strong>, which means it canâ€™t ever be on the LHS part of an assignment. <strong>Literals are typically rvalues</strong>.</p><blockquote><p>In C: an <em>rvalue</em> is an expression that can only appear on the RHS of an assignment.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>    <span class=c1>// i is an lvalue, 10 is an rvalue.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=mi>2</span>  <span class=c1>// i * 2 is an rvalue.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=mi>2</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>         <span class=c1>// error: expression must be a modifiable lvalue.
</span></span></span></code></pre></td></tr></table></div></div><ul><li>Rvalues are important because they <strong>enable move semantics</strong> in C++. There are many instances in C++ code where itâ€™s not necessary to copy a value or object from one place to another. E.g. when passing arguments into a function or when saving the returned value on the callerâ€™s side. Implementing move semantics, where appropriate, is great for performance because it prevents expensive copies.</li></ul><blockquote><p>Very loosely, Bjarne describes lvalues as &ldquo;something that can appear on the left-hand side of an assignment&rdquo; and rvalues as &ldquo;a value that you can&rsquo;t assign to.&rdquo;</p></blockquote><a href=#l-value-reference><h3 id=l-value-reference><span class=hanchor arialabel=Anchor># </span>L-Value Reference</h3></a><p>An <strong>lvalue reference</strong> uses a single ampersand <code>&</code>, eg. <code>string& s = "..."</code></p><ul><li>Const lvalue reference types (eg. <code>const string& s</code>) as a function parameter allow the caller to <strong>pass both an l-value or r-value, equivalently</strong>.</li></ul><a href=#r-value-reference><h3 id=r-value-reference><span class=hanchor arialabel=Anchor># </span>R-Value Reference</h3></a><p>An <strong>rvalue reference</strong> uses double ampersand <code>&&</code>, eg. <code>string&& s</code>. Youâ€™d use this to receive rvalues in functions, like literals and temporary objects. Doing this means you can avoid unnecessarily copying a value that is a â€˜throwawayâ€™ on the callerâ€™s side.</p><ul><li>You can define a <em>move constructor</em> and <em>move assignment operator</em> that take in an rvalue reference instead of a const lvalue reference. Itâ€™ll behave the same way, but it wonâ€™t guarantee the source to be unchanged.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Takes in an l-value reference which forces the caller to pass in variables.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>GreetLvalue</span><span class=p>(</span><span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>    
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Takes in an r-value reference which forces the caller to pass in literals 
</span></span></span><span class=line><span class=cl><span class=c1>// or temporary objects.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>GreetRvalue</span><span class=p>(</span><span class=n>string</span> <span class=o>&amp;&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>   
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>             
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Const references let the caller pass both lvalues and rvalues alike.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Greet</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>name</span><span class=p>)</span> <span class=p>{</span>    
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>name</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>  <span class=c1>// Note: `const string &amp;` will create a temporary variable behind the
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>                        <span class=c1>// scenes and then assign it to `name`. This is why you can pass both
</span></span></span><span class=line><span class=cl><span class=c1></span>                         <span class=c1>// lvalues and rvalues to a const l-value reference like this.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>myName</span> <span class=o>=</span> <span class=s>&#34;Tim&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>GreetLvalue</span><span class=p>(</span><span class=n>myName</span><span class=p>);</span>     <span class=c1>// âœ“
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>GreetLvalue</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>   <span class=c1>// Error: cannot bind non-const lvalue reference.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>GreetRvalue</span><span class=p>(</span><span class=n>myName</span><span class=p>);</span>     <span class=c1>// Error: cannot bind rvalue reference.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>GreetRvalue</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>   <span class=c1>// âœ“
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>  <span class=n>Greet</span><span class=p>(</span><span class=n>myName</span><span class=p>);</span>           <span class=c1>// âœ“
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>Greet</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>         <span class=c1>// âœ“
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#modularity><h2 id=modularity><span class=hanchor arialabel=Anchor># </span>Modularity</h2></a><a href=#separate-compilation><h3 id=separate-compilation><span class=hanchor arialabel=Anchor># </span>Separate Compilation</h3></a><p>C++ supports <em>separate compilation</em>, where code in one file only sees the declarations for the types and functions it uses, not the implementation. This decouples the smaller units comprising a project and minimises compilation time since each unit can be compiled only if they change.</p><p>We take advantage of separate compilation by listing out declarations in a header file. Example:
![[Knowledge/Engineering/Languages/assets/vector-header-cpp.png|500]]</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Vector.h â€” the header file defining the Vector class and its properties and methods (but without implementation)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>Vector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>Vector</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span><span class=o>&amp;</span> <span class=k>operator</span><span class=p>[[]];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>double</span><span class=o>*</span> <span class=n>elements</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>capacity</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Vector.cpp â€” the implementation for Vector.h
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;Vector.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Implementing the constructor and methods outside of the class definition.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Vector</span><span class=o>::</span><span class=n>Vector</span><span class=p>(</span><span class=kt>int</span> <span class=n>s</span><span class=p>)</span> <span class=o>:</span><span class=n>elements</span><span class=p>{</span><span class=k>new</span> <span class=kt>double</span><span class=p>[</span><span class=n>s</span><span class=p>]},</span> <span class=n>capacity</span><span class=p>{</span><span class=n>s</span><span class=p>}</span> <span class=p>{}</span>   
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>double</span><span class=o>&amp;</span> <span class=n>Vector</span><span class=o>::</span><span class=k>operator</span><span class=p>[[]]</span> <span class=p>{</span> <span class=k>return</span> <span class=n>elements</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>Vector</span><span class=o>::</span><span class=n>size</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>capacity</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// user.cpp â€” the user of Vector.h, who has know idea about how it&#39;s implemented.
</span></span></span><span class=line><span class=cl><span class=c1>//            It only knows about the declarations inside Vector.h
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Vector.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>Vector</span> <span class=n>v</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vector size: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#namespaces><h3 id=namespaces><span class=hanchor arialabel=Anchor># </span>Namespaces</h3></a><p>Namespaces <em><strong>define a scope for a set of names</strong></em>. It&rsquo;s used to organise your project into logical groups and to prevent name collisions when you&rsquo;re using libraries, for example.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>UNSW</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=n>string</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>Student</span><span class=p>(</span><span class=n>string</span> <span class=n>id</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>this</span><span class=o>-&gt;</span><span class=n>id</span> <span class=o>=</span> <span class=n>id</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>UNSW</span><span class=o>::</span><span class=n>Student</span> <span class=n>me</span><span class=p>(</span><span class=s>&#34;z5258971&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>me</span><span class=p>.</span><span class=n>id</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>You can do namespace aliases to shorten namespaces. Never do this in header files<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>namespace</span> <span class=n>testing</span> <span class=o>=</span> <span class=o>::</span><span class=n>my</span><span class=o>::</span><span class=n>testing</span><span class=o>::</span><span class=n>framework</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li>Use <code>using</code> to avoid using a fully qualified name every time.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>Any identifier you declare that&rsquo;s <em>not within</em> a namespace will be implicitly part of the <em>global namespace</em>. Globally scoped identifiers are accessible with <code>::</code> without specifying a name.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>24</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>bar</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>;</span>     <span class=c1>// 24. Picks the closer `Foo::num` over `::num`.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>::</span><span class=n>num</span><span class=p>;</span>   <span class=c1>// 42.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#error-handling><h2 id=error-handling><span class=hanchor arialabel=Anchor># </span>Error Handling</h2></a><p>C++ provides the familiar <code>try</code> and <code>catch</code> blocks for error handling. Note that when an exception is thrown, the destructor for the object that threw the exception is called, enabling <a href=/Knowledge/Engineering/Languages/C++#raii rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>RAII</a>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>try</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span><span class=p>(</span><span class=n>out_of_range</span><span class=o>&amp;</span> <span class=n>err</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>catch</span><span class=p>(...)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// All exceptions are caught here when you use `...`
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span><span class=p>;</span>  <span class=c1>// Use `throw` on its own to re-throw the exception.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#custom-exceptions><h3 id=custom-exceptions><span class=hanchor arialabel=Anchor># </span>Custom Exceptions</h3></a><p>Just inherit from <code>std::exception</code>, implement the <code>const char* what() const throw()</code> method, and a constructor that takes in a <code>string</code> error message.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyException</span> <span class=o>:</span> <span class=k>public</span> <span class=n>std</span><span class=o>::</span><span class=n>exception</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>MyException</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>message</span><span class=p>)</span> <span class=o>:</span> <span class=n>message_</span><span class=p>(</span><span class=n>message</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>  <span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=nf>what</span><span class=p>()</span> <span class=k>const</span> <span class=k>throw</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=n>message_</span><span class=p>.</span><span class=n>c_str</span><span class=p>();</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>message_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#noexcept><h3 id=noexcept><span class=hanchor arialabel=Anchor># </span>noexcept</h3></a><p>Use <code>noexcept</code> at the end of a function signature to declare that it will never throw an exception. If it does in fact throw an exception, it will just directly <code>std::terminate()</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>something_bad</span><span class=p>()</span> <span class=k>noexcept</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><p>Why use it?</p><ul><li>The compiler generates slightly more optimal code since it can assume it doesn&rsquo;t have to support try-catch control flow.</li><li>For documentation for other developers.</li></ul><a href=#classes><h2 id=classes><span class=hanchor arialabel=Anchor># </span>Classes</h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Human</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=n>string</span> <span class=n>scientific_name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Default constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Having this means that `Human` objects will never be uninitialised.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Human</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Destructor. Called when an instance goes out of scope or on exception.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>Human</span><span class=p>()</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Human</span><span class=p>(</span><span class=kt>int</span> <span class=n>age</span><span class=p>,</span> <span class=n>string</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=c1>// Non-const static class variables must be initialised outside the class definition.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=n>Human</span><span class=o>::</span><span class=n>scientific_name</span> <span class=o>=</span> <span class=s>&#34;homo sapiens&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// **Allocating the object on the heap**
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Human</span><span class=o>*</span> <span class=n>me1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Human</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>me1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// **Allocating the object on the stack** (meaning there&#39;s not need to call delete)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Human</span> <span class=n>me2</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Human</span> <span class=n>me3</span><span class=p>{</span><span class=mi>20</span><span class=p>,</span> <span class=s>&#34;Tim&#34;</span><span class=p>};</span>     <span class=c1>// An equivalent way of instantiating a class.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Human</span> <span class=n>me4</span><span class=p>;</span>                <span class=c1>// Implicitly calls the default constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Why do non-const static members have to be initialised outside the class? See this
<a href="https://stackoverflow.com/questions/47882456/why-do-non-constant-static-variables-need-to-be-initialized-outside-the-class#:~:text=In-the-case-of-a,as-part-of-an-object." rel=noopener>explanation</a>.</li></ul><a href=#inheritance><h3 id=inheritance><span class=hanchor arialabel=Anchor># </span>Inheritance</h3></a><p>Inheritance is done with the syntax <code>class Foo : public Bar</code>. Also see <a href=/Knowledge/Engineering/Languages/C++#protected-and-private-inheritance rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>Protected and Private Inheritance</a>.</p><ul><li>Constructors are not inherited by default.</li><li>Child constructors can reference the parent constructors in the <a href=/Knowledge/Engineering/Languages/C++#member-initialiser-list rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>member initialiser list</a> following the constructor signature.</li><li>Multiple inheritance is done like this: <code>class Foo : public Bar, public Baz</code>.</li></ul><a href=#member-initialiser-list-and-delegating-constructors><h3 id=member-initialiser-list-and-delegating-constructors><span class=hanchor arialabel=Anchor># </span>Member Initialiser List and Delegating Constructors</h3></a><p>Use a member initialiser list following a constructor signature to initialise class variables and invoke other constructors.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>baz</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>()</span> <span class=o>:</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span> <span class=o>:</span> <span class=n>Foo</span><span class=p>(</span><span class=n>num</span><span class=p>,</span> <span class=s>&#34;&#34;</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>,</span> <span class=n>string</span> <span class=n>str</span><span class=p>)</span> <span class=o>:</span> <span class=n>bar</span><span class=p>(</span><span class=n>num</span><span class=p>),</span> <span class=n>baz</span><span class=p>(</span><span class=n>str</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>âš ï¸ This is not to be confused with <a href=/Knowledge/Engineering/Languages/C++#copy-list-and-direct-initialisation rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>list initialisation</a>.</li><li><strong>This is <em>not</em> just a shorthand</strong>:<ul><li>You must initialise const members in the member initialiser list.</li><li>Initialisation is always done before the executing the constructor body.</li></ul></li><li><strong>Order matters</strong>. Initialise members in the same order that they&rsquo;re declared in the class as a good practice.</li></ul><a href=#virtual-methods><h3 id=virtual-methods><span class=hanchor arialabel=Anchor># </span>Virtual Methods</h3></a><p>Virtual methods are methods that have an implementation but which <em>may</em> be redefined later by a child class.</p><ul><li><em><strong>Pure virtual method</strong></em> â€” where a function <em><strong>must</strong></em> be defined by a class deriving from this one
```cpp
class Foo {
public:
virtual void Bar() <strong>= 0</strong>;
}<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=o>-</span><span class=w> </span><span class=o>***</span><span class=n>Abstract</span><span class=w> </span><span class=n>class</span><span class=o>***</span><span class=w> </span><span class=err>â€”</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>class</span><span class=w> </span><span class=n>that</span><span class=w> </span><span class=n>has</span><span class=w> </span><span class=n>at</span><span class=w> </span><span class=n>least</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=o>*</span><span class=n>pure</span><span class=w> </span><span class=n>virtual</span><span class=w> </span><span class=n>method</span><span class=o>*</span><span class=p>.</span><span class=w> </span><span class=n>It</span><span class=w> </span><span class=n>cannot</span><span class=w> </span><span class=n>be</span><span class=w> </span><span class=n>instantiated</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>-</span><span class=w> </span><span class=n>C</span><span class=o>++</span><span class=w> </span><span class=n>doesn</span><span class=s1>&#39;t have an `abstract` keyword like Java. To make a class abstract, you just define 1 pure virtual method
</span></span></span></code></pre></td></tr></table></div></div></li><li><em><strong>Concrete class</strong></em> â€” a class that has no <em>pure virtual functions</em> and can be directly instantiated</li><li><code>override</code> keyword â€” is an <em>optional</em> qualifier that tells programmers that a method is meant to provide a definition for a virtual method from a base class</li><li>Any class with virtual functions should always provide a virtual <em>destructor</em></li></ul><a href=#object-slicing><h3 id=object-slicing><span class=hanchor arialabel=Anchor># </span>Object Slicing</h3></a><p>When you copy a child object to a variable of the type of the parent, the members specific to the child are &lsquo;sliced off&rsquo; so that the resulting object is a valid instance of the parent type.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Parent</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>Child</span><span class=p>();</span>   <span class=c1>// When the child object is copied to a variable of a parent type,
</span></span></span><span class=line><span class=cl><span class=c1></span>                        <span class=c1>// all its members and overridden methods are 
</span></span></span></code></pre></td></tr></table></div></div><ul><li>An important consequence of object slicing is that you can no longer call the child class&rsquo; overridden methods on when the variable is of the parent type. In the following example, the output is &ldquo;Something&rdquo;:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>do_something</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Something</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span> <span class=nc>Child</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>do_something</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Overridden</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Parent</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>Child</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>.</span><span class=n>do_something</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>If you used <code>Parent* foo = new Child();</code> instead, the output would be &ldquo;Overridden&rdquo;.</li></ul></li></ul><blockquote><p>Object slicing does not happen in the same way in most other languages, like Java. When you do <code>Parent foo = new Child()</code> in Java, <code>foo</code>&rsquo;s overriden methods are still intact and will be called instead of the base method. This is because languages like Java use implicit references to manipulate objects and objects are copied by reference by default, unlike C++.
<img src=/Knowledge/Engineering/Languages/assets/object-slicing-cpp.png width=600>
(sourced from
<a href=https://www.geeksforgeeks.org/object-slicing-in-c/ rel=noopener>GeeksForGeeks</a>)</p></blockquote><a href=#instantiating-classes><h3 id=instantiating-classes><span class=hanchor arialabel=Anchor># </span>Instantiating Classes</h3></a><p>There are several ways of instantiating a class:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Allocated on the stack:
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f1</span><span class=p>;</span>              <span class=c1>// Implicitly calls the default constructor, Foo().
</span></span></span><span class=line><span class=cl><span class=c1></span>                         <span class=c1>// In other languages like C#, this would be an uninitialised object.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f2</span> <span class=o>=</span> <span class=n>Foo</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>     <span class=c1>// Copy initialisation.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f3</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>          <span class=c1>// Also copy initialisation.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f4</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>           <span class=c1>// Direct initialisation.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f5</span><span class=p>{</span><span class=mi>1</span><span class=p>};</span>           <span class=c1>// List initialisation (generally preferred because it avoids implicit type 
</span></span></span><span class=line><span class=cl><span class=c1></span>                         <span class=c1>// conversions and avoids creating unnecessary temporary objects).
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f6</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>};</span>        <span class=c1>// Also copy initialisation, but with an initialiser list.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>f7</span><span class=p>();</span>            <span class=c1>// You&#39;d think this is calling the default constructor, but it&#39;s not.
</span></span></span><span class=line><span class=cl><span class=c1></span>                         <span class=c1>// See &#39;most vexing parse&#39;. Use `Foo f7;` instead to call the default ctor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Manually allocated on the heap (avoid when posssible):
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=o>*</span> <span class=n>f8</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>f8</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Note that when using brace initialisation, the constructor that takes in a <code>std::initializer_list</code> will be preferred for invocation.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Initialiser list constructor called.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Normal constructor called.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>b</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>  <span class=c1>// Normal constructor called.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span> <span class=n>c</span><span class=p>{</span><span class=mi>42</span><span class=p>};</span>  <span class=c1>// Initialiser list constructor called.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>General Guidelines
<a href=https://stackoverflow.com/questions/9976927/when-to-use-the-brace-enclosed-initializer rel=noopener>*</a>:</strong></p><ul><li>Use <code>=</code> if the (single) value you are initialising with is intended to be theÂ <em>exact value</em>Â of the object.<ul><li>Prefer using <code>=</code> when assigning to <code>auto</code> variables.</li><li>Prefer when initialising variables with primitive types (eg. int, bool, float, etc.).</li></ul></li><li>Use <code>{ }</code> if the values you are initialising with are a list of values to beÂ <em>stored in the object</em>Â (like the elements of a vector/array, or real/imaginary part of a complex number).<ul><li>Prefer using { } in the majority of cases because it can be used in every context and is less error-prone than the alternatives.</li></ul></li><li>Use <code>( )</code> if the values you are initialising with areÂ <em>not</em>Â values to be stored, butÂ <em>describe</em>Â the intended value/state of the object, use parentheses.<ul><li>Essentially, if the intent is to call a particular constructor, then use parentheses <code>( )</code>.</li><li>E.g. good example with <code>vector</code>:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>**</span><span class=n>v</span><span class=p>(</span><span class=mi>10</span><span class=p>)</span><span class=o>**</span><span class=p>;</span>          <span class=c1>// Empty vector of 10 elements
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>v</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>   <span class=c1>// Prints **10**
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>**</span><span class=n>u</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>}</span><span class=o>**</span><span class=p>;</span>     <span class=c1>// Vector with elements 1, 2, 3
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>u</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>   <span class=c1>// Prints **3**
</span></span></span></code></pre></td></tr></table></div></div></li></ul></li><li>In general, prefer allocating on the stack rather than the heap, unless you need the object to persist after the function terminates.<ul><li>You&rsquo;d have to use <code>unique_ptr</code> if you don&rsquo;t want to memory-manage with <code>new</code> and <code>delete</code>.<ul><li>Allocating on the heap is less performant than allocating on the stack. <strong>Stack allocation is faster</strong>Â because the access pattern makes it trivial to allocate and deallocate memory from it (a pointer/integer is simply incremented or decremented), while the heap has much more complex bookkeeping involved in memory allocation/deallocation.</li></ul></li><li>Very large objects should be allocated on the heap to prevent stack overflow (the heap is larger than the stack).</li></ul></li><li>Note: In Java/C#, you canâ€™t allocate objects on the stack, theyâ€™d all be allocated on the heap. You could use a <code>struct</code> instead</li></ul><a href=#const-objects><h3 id=const-objects><span class=hanchor arialabel=Anchor># </span>Const Objects</h3></a><p><code>const</code> objects prevents its fields being modified. You can only call its const methods.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Student</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Student</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Andrew&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setName</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>name</span> <span class=o>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>Student</span> <span class=n>s</span><span class=p>;</span>        
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;Taylor&#34;</span><span class=p>;</span>     <span class=c1>// âœ˜ not fine because this modifies a class variable.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>s</span><span class=p>.</span><span class=n>setName</span><span class=p>(</span><span class=s>&#34;Taylor&#34;</span><span class=p>);</span>   <span class=c1>// âœ˜ not fine because this calls a non-const method.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>Note the differences between <code>const Foo foo = ...;</code> in C++ vs. <code>const foo = ...</code> in JavaScript/TypeScript. In JavaScript, you can still mutate the fields freely by default, you just can&rsquo;t reassign <code>foo</code> to point to a different object.</p></blockquote><a href=#final-methods><h3 id=final-methods><span class=hanchor arialabel=Anchor># </span>Final Methods</h3></a><p>Postfixing a method signature with the <code>final</code> keyword will make it so that it cannot be overridden by a deriving class.</p><ul><li>Why not just declare a method without the <code>virtual</code> modifier? Wouldn&rsquo;t that prevent overriding? See
<a href=https://stackoverflow.com/questions/8824587/what-is-the-purpose-of-the-final-keyword-in-c11-for-functions rel=noopener>why final exists</a>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>FooParent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=n>Info</span><span class=p>()</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=o>:</span> <span class=k>public</span> <span class=n>FooParent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Info</span><span class=p>()</span> <span class=k>override</span> <span class=k>final</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>FooChild</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Info</span><span class=p>()</span> <span class=k>override</span> <span class=p>{}</span>      <span class=c1>// Error: cannot override final funtion
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#explicit-methods><h3 id=explicit-methods><span class=hanchor arialabel=Anchor># </span>Explicit Methods</h3></a><p>You can prefix <code>explicit</code> in front of a constructor or method signature to prevent implicit type conversions.</p><ul><li>Itâ€™s good practice to make constructors <code>explicit</code> by default, unless an implicit conversion makes sense semantically.
<a href=https://stackoverflow.com/questions/3716453/is-it-a-good-practice-to-make-constructor-explicit rel=noopener>Source</a>.<ul><li>Why doesn&rsquo;t the language make constructors explicit by default? Because people thought it was cleaner and now it&rsquo;s irreversible because people want backward compatibility (
<a href=https://stackoverflow.com/questions/4607047/why-constructors-arent-explicit-by-default rel=noopener>source</a>).</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyVector</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>explicit</span> <span class=nf>MyVector</span><span class=p>(</span><span class=kt>int</span> <span class=n>num</span><span class=p>)</span> <span class=o>:</span> <span class=n>size</span><span class=p>(</span><span class=n>num</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MyVector</span> <span class=n>v</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>      <span class=c1>// Without an explicit constructor, this actually invokes `MyVector(2)`.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>                        <span class=c1>// When you define `explicit MyVector(int num)`, this call would cause an error.
</span></span></span></code></pre></td></tr></table></div></div><a href=#friend-classes><h3 id=friend-classes><span class=hanchor arialabel=Anchor># </span>Friend Classes</h3></a><p>Inside your class body, you can declare a class as a <code>friend</code> which grants them full access to all your class&rsquo; members, including private ones. Just remember the inappropriate but memorable phrase: <strong>&ldquo;friends can access your privates&rdquo;</strong>.</p><p>A class can declare who their <em>friends</em> are in their body. Friends are then able to access everything within that class, including private members.</p><ul><li>You can only declare whoâ€™s allowed to access you, <em>not who you can have access to</em>. Like in real life, <strong>you canâ€™t grant yourself access to someone elseâ€™s privates</strong>, but you can grant others access to yours ðŸ˜.<ul><li>You can declare other classes or specific functions as your friends.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Baby</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Baby</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>name</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Methods of `Mother` will be able to see everything in `Baby`.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>friend</span> <span class=k>class</span> <span class=nc>Mother</span><span class=p>;</span>        
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Mother</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Mother</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>babyName</span><span class=p>)</span> <span class=o>:</span> <span class=n>baby</span><span class=p>(</span><span class=n>babyName</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>rename_baby</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>new_name</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// This is only possible because of `friend class Mother`.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>baby</span><span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=n>new_name</span><span class=p>;</span>    
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Baby</span> <span class=n>baby</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Mother</span> <span class=n>mum</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>mum</span><span class=p>.</span><span class=n>RenameBaby</span><span class=p>(</span><span class=s>&#34;Andy&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>When to use friend classes?</strong></p><ul><li>When you want to write white-box unit tests, you can declare the unit test class as a friend. Itâ€™s good for unit testing private methods which you don&rsquo;t want to expose to anyone other than the unit testing class.<ul><li>Caveat: itâ€™s
<a href=https://stackoverflow.com/questions/4171310/what-is-wrong-with-making-a-unit-test-a-friend-of-the-class-it-is-testing/4171331#4171331 rel=noopener>debatable</a> whether itâ€™s good practice to test private methods. Testing a public method should indirectly test a private method anyway.</li></ul></li></ul><blockquote><p>Use friend classes sparingly. If you&rsquo;re in a situation where you want to use a friend class, it&rsquo;s a red flag, design-wise.</p></blockquote><a href=#deleted-functions><h3 id=deleted-functions><span class=hanchor arialabel=Anchor># </span>Deleted Functions</h3></a><p>Just like how you can use <code>= 0</code> to declare a function to be a pure virtual function, you can use <code>= delete</code> to declare a function to be a <em>deleted function</em>, where it can no longer be invoked. This is mostly used to suppress operations and constructors to prevent misuse.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Deleted copy constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Deleted assignment operator.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>A</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=n>a1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span> <span class=n>a2</span> <span class=o>=</span> <span class=n>a1</span><span class=p>;</span> <span class=c1>// error, copy constructor is deleted.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>a1</span> <span class=o>=</span> <span class=n>a2</span><span class=p>;</span>   <span class=c1>// error, assignment operator is deleted.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#defaulted-functions><h3 id=defaulted-functions><span class=hanchor arialabel=Anchor># </span>Defaulted Functions</h3></a><p>Like <em>deleted functions</em>, you can postfix a constructor or method signature with <code>= default</code> to make the compiler supply a default implementation.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Default copy constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>A</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Default assignment.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>A</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>A</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Default destructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>A</span><span class=p>()</span> <span class=o>=</span> <span class=k>default</span><span class=p>;</span> 
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#raii><h3 id=raii><span class=hanchor arialabel=Anchor># </span>RAII</h3></a><p>The technique of acquiring resources in the constructor and then freeing them in the destructor is called <em>RAII (Resource Acquisition is Initialisation)</em>. The idea is about coupling the use of a resource to the lifetime of an object so that when it goes out of scope, or when it throws an exception, the resources it held are guaranteed to be released. Always design classes with RAII in mind.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ResourceHolder</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ResourceHolder</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>arr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=mi>12</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>ResourceHolder</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span><span class=p>[]</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>This works well for mutexes where you can acquire the lock in the constructor and unlock it in the destructor.</li><li>RAII is implemented religiously in standard library resources such as threads, files, data structures, etc.</li></ul><a href=#operator-overloading><h3 id=operator-overloading><span class=hanchor arialabel=Anchor># </span>Operator Overloading</h3></a><p>You can define operations on classes by overloading operators like <code>+</code>, <code>+=</code>, <code>==</code>, etc.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Coordinate</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Coordinate</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>Coordinate</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>{.</span><span class=n>x</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>x</span> <span class=o>+</span> <span class=n>other</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=k>this</span><span class=o>-&gt;</span><span class=n>y</span> <span class=o>+</span> <span class=n>other</span><span class=p>.</span><span class=n>y</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Coordinate</span> <span class=n>foo</span><span class=p>{</span><span class=mi>42</span><span class=p>,</span> <span class=mi>24</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Coordinate</span> <span class=n>bar</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>Coordinate</span> <span class=n>result</span> <span class=o>=</span> <span class=n>foo</span> <span class=o>+</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Coordinate: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>x</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>result</span><span class=p>.</span><span class=n>y</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Operator overloading is just a type of <a href=/Knowledge/Engineering/Programming/Object-Oriented-Programming#static-polymorphism rel=noopener class=internal-link data-src=/Knowledge/Engineering/Programming/Object-Oriented-Programming>static polymorphism</a>. <strong>Operators are just functions</strong>. When compiled, expressions with operators are just converted to equivalent function calls. E.g. <code>a += b</code> becomes <code>operator+=(a, b)</code>.</li><li>Operator overloading also exists in C#, Java, Python, etc.</li><li>Make sure the copy constructor/assignment is implemented such that logical equivalences hold. E.g. <code>a != b</code> should be the same as <code>!(a == b)</code>, etc.</li></ul><a href=#copy-constructor-and-operation><h3 id=copy-constructor-and-operation><span class=hanchor arialabel=Anchor># </span>Copy Constructor and Operation</h3></a><p>A <em>copy constructor</em> is a constructor that takes in a (typically const) reference to an instance of the same class. A <em>copy assignment operator overload</em> also takes in a (typically const) reference to an instance of the same class and returns a reference to an instance of the same class.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Copy assignment operator.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>Foo</span><span class=o>&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>  
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>The copy constructor is invoked implicitly in a number of situations:</p><ul><li>Passing by value to a function (the function creates its own copy for local use).</li><li>Returning a value will create a copy for the caller (this can be very inefficient, which is why optimisations like <a href=/Knowledge/Engineering/Languages/C++#copy-elision rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>copy elision</a> and <a href=/Knowledge/Engineering/Languages/C++#move-constructor-and-operation rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>move semantics</a> exists).</li><li>Copy initialisation:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>bar</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>baz</span> <span class=o>=</span> <span class=n>foo</span><span class=p>;</span>     <span class=c1>// Implicitly calls the copy constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>baz</span> <span class=o>=</span> <span class=n>bar</span><span class=p>;</span>         <span class=c1>// Calls copy assignment operator, not the copy constructor.
</span></span></span></code></pre></td></tr></table></div></div></li></ul><p>If you don&rsquo;t implement the copy constructor yourself, the compiler generates a default copy constructor that performs a simple memberwise copy to form a new object. Often, this default copy constructor is acceptable. For sophisticated concrete types and abstract types, the default implementation should be <a href=/Knowledge/Engineering/Languages/C++#deleted-functions rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>deleted</a> or manually implemented.</p><ul><li><p>An example of when default copy could be bad: when your class holds a pointer to a resource, a memberwise copy would copy the pointer over to the new object. Now both objects would affect the same resource.</p><p>E.g. suppose we have a crappy <code>Vector</code> implementation that uses the default copy constructor and copy assignment operator. <code>Vector</code> manages a pointer to an underlying array. When you just do a memberwise copy, you only copy over the pointer to the underlying array, not the underlying array itself.
<img src=/Knowledge/Engineering/Languages/assets/bad-copy-vector-cpp.png width=600></p></li></ul><a href=#move-constructor-and-operation><h3 id=move-constructor-and-operation><span class=hanchor arialabel=Anchor># </span>Move Constructor and Operation</h3></a><p>A <em>move constructor</em> is a constructor that takes in an <a href=/Knowledge/Engineering/Languages/C++#r-value-reference rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>rvalue reference</a> to an instance of the same class. A move assignment operator overload takes in an rvalue reference (to an instance of the same class) and returns a reference to the same class.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Move constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move assignment operator.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>Suppose you have a function that returns a large object (e.g. a big matrix) and you want to avoid copying it to the caller, which would be very wasteful of clock cycles. Since you can&rsquo;t return a reference to a local variable, and it is a bad idea to resort to the C-style returning of a pointer to a <code>new</code> object that the caller has to memory-manage, the best option is to use a move constructor.</p><ul><li>Move constructors are implemented to &lsquo;steal&rsquo; over the resources held by the given instance (hence why we don&rsquo;t take in a <code>const</code> rvalue reference). This means transferring over things like underlying data structures, file handles, etc.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vals</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>arr_</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>vals</span><span class=p>.</span><span class=n>size</span><span class=p>()];</span>
</span></span><span class=line><span class=cl>        <span class=n>size_</span> <span class=o>=</span> <span class=n>vals</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=nl>val</span> <span class=p>:</span> <span class=n>vals</span><span class=p>)</span> <span class=n>arr_</span><span class=p>[</span><span class=n>i</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Steal the given Foo&#39;s members/resources.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>arr_</span> <span class=o>=</span> <span class=n>other</span><span class=p>.</span><span class=n>arr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size_</span> <span class=o>=</span> <span class=n>other</span><span class=p>.</span><span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>other</span><span class=p>.</span><span class=n>arr_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>other</span><span class=p>.</span><span class=n>size_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Move assignment operator.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Foo</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=k>this</span> <span class=o>==</span> <span class=o>&amp;</span><span class=n>other</span><span class=p>)</span> <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>arr_</span> <span class=o>=</span> <span class=n>other</span><span class=p>.</span><span class=n>arr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>size_</span> <span class=o>=</span> <span class=n>other</span><span class=p>.</span><span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>other</span><span class=p>.</span><span class=n>arr_</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>other</span><span class=p>.</span><span class=n>size_</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>*</span><span class=k>this</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>print_vals</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Values: &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>size_</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>arr_</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>arr_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>size_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>foo</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>bar</span><span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>.</span><span class=n>print_vals</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>bar</span><span class=p>.</span><span class=n>print_vals</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bar</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>foo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>foo</span><span class=p>.</span><span class=n>print_vals</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>bar</span><span class=p>.</span><span class=n>print_vals</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#stdmove><h4 id=stdmove><span class=hanchor arialabel=Anchor># </span>std::move</h4></a><p>Suppose you have a class <code>Foo</code> that implements a move constructor: <code>Foo(Foo&& other)</code>. To invoke this, you&rsquo;d do something like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=nf>bar</span><span class=p>((</span><span class=n>Foo</span><span class=o>&amp;&amp;</span><span class=p>)</span><span class=n>foo</span><span class=p>);</span>   <span class=c1>// Invoke the move constructor.
</span></span></span></code></pre></td></tr></table></div></div><p>Since this is ugly and doesn&rsquo;t work for <code>auto</code> inferred types, we have <code>std::move</code> instead.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=nf>bar</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>move</span><span class=p>(</span><span class=n>foo</span><span class=p>));</span>   <span class=c1>// Read this like: &#34;moving foo&#39;s contents to bar.&#34;
</span></span></span></code></pre></td></tr></table></div></div><p>Once you&rsquo;ve used <code>move(foo)</code>, you mustn&rsquo;t use <code>foo</code> again. Because it&rsquo;s error prone, Bjarne recommends to use it sparingly and only when the performance improvements justify it.</p><blockquote><p><code>std::move</code> doesn&rsquo;t actually move anything, which is a bit misleading. It just converts an lvalue to rvalue reference so as to invoke the move constructor. It has zero side effects and behaves very much like a typecast. The actual &lsquo;moving&rsquo; itself is done by the move constructor.</p><p>A less mislead name for <code>std::move</code> would have been <code>rvalue_cast</code>, according to Bjarne.</p><p><code>std::move(foo)</code> basically says &ldquo;you are now allowed to steal resources from <code>foo</code>&rdquo;.</p></blockquote><a href=#templates><h2 id=templates><span class=hanchor arialabel=Anchor># </span>Templates</h2></a><p>Templates in C++ are a code generation system that lets you specify a general implementation of a class or function and then generate specialised instances of that template for different types, on demand.</p><ul><li>Templates provides everything offered by generics in languages like Java, plus more.</li><li>Since templates are purely a compile-time feature, there is no real difference between template-generated code and equivalent handwritten code.</li></ul><p>To make a class or function a template, just prefix the definition with the <code>template</code> keyword followed by a list of type parameters: <code>template &lt;typename A, typename B, ...></code>.</p><ul><li>Read <code>template &lt;typename T></code> as &ldquo;for all types T, &mldr;&rdquo;</li><li>You can also use the <code>class</code> keyword instead of <code>typename</code>. Theyâ€™re interchangeable.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// These two are equivalent:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div></li><li>Templates can take in <strong>value arguments</strong> as well as type arguments:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=kt>int</span> <span class=n>N</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span><span class=o>*</span> <span class=n>make_array</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=n>T</span><span class=p>[</span><span class=n>N</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>arr</span> <span class=o>=</span> <span class=n>make_array</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=mi>12</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>arr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#templates-vs-generics><h3 id=templates-vs-generics><span class=hanchor arialabel=Anchor># </span>Templates vs. Generics</h3></a><p>Templates are massively different from generics in other OOP languages like Java.</p><p>In Java, generics are mainly syntactic sugar that help programmers avoid boilerplate code. In C++, templates are a code generation system that enables generic programming and more. Some main differences:</p><blockquote><p>Think of C++&rsquo;s templates as very sophisticated preprocessor commands. It&rsquo;s used to <em>generate</em> type-safe code. In Java&rsquo;s generic system,
<a href=https://www.baeldung.com/java-type-erasure rel=noopener>type erasure</a> is used, resulting in a single implementation of the generic class/function rather than many specialised instances of a template like in C++.</p></blockquote><a href=#function-templates><h3 id=function-templates><span class=hanchor arialabel=Anchor># </span>Function Templates</h3></a><p>Function templates are a generalised algorithm that the compiler can generate copies of for usage with specific types.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>U</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>foo</span><span class=p>(</span><span class=n>T</span> <span class=n>t</span><span class=p>,</span> <span class=n>U</span> <span class=n>u</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>T</code> is a <em><strong>type argument</strong></em>. Its scope is limited to the function signature and body.</li><li>Strictly speaking, a function template is not really a function. Itâ€™s a generalisation of an algorithm that is used as a tool by the compiler for generating similar but independent functions.</li><li>The act of generating a function from a function template by the compiler is called <em><strong>template instantiation</strong></em></li></ul><p>A generic swap function:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>      <span class=c1>// Start of T&#39;s scope
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=n>swap</span><span class=p>(</span><span class=n>T</span><span class=o>&amp;</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span><span class=o>&amp;</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>tmp</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>                          <span class=c1>// End of T&#39;s scope
</span></span></span></code></pre></td></tr></table></div></div><ul><li>When you invoke <code>swap&lt;int>(i, j)</code>, the compiler will <em>instantiate</em> a function with signature <code>void swap&lt;int>(int& a, int& b)</code> for you by plugging in the types into the template function you defined.<ul><li>Template instantiation is done on-demand when you compile.</li><li>The compiler is smart enough to avoid instantiating duplicate functions.</li></ul></li></ul><a href=#class-templates><h3 id=class-templates><span class=hanchor arialabel=Anchor># </span>Class Templates</h3></a><p>Basically <a href=/Knowledge/Engineering/Languages/C++#function-templates rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>function templates</a>, but with classes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Item</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Stack</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>push</span><span class=p>(</span><span class=n>Item</span> <span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>show</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>&gt;</span> <span class=n>vec_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// When implementing methods outside of the class, you must fully qualify
</span></span></span><span class=line><span class=cl><span class=c1>// the method name with the prefix `MyContainer&lt;T&gt;::`.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Anything following `::` will be within the class&#39; scope, meaning that
</span></span></span><span class=line><span class=cl><span class=c1>// specifying &lt;T&gt; becomes optional again â€” because T is known in the class
</span></span></span><span class=line><span class=cl><span class=c1>// body.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Item</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>&gt;::</span><span class=n>push</span><span class=p>(</span><span class=n>Item</span> <span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vec_</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>Item</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Stack</span><span class=o>&lt;</span><span class=n>Item</span><span class=o>&gt;::</span><span class=n>show</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>Item</span><span class=o>&amp;</span> <span class=nl>item</span> <span class=p>:</span> <span class=n>vec_</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>item</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>nums</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>nums</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nums</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=mi>24</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>nums</span><span class=p>.</span><span class=n>show</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Stack</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>strs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>strs</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>strs</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=s>&#34;World&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>strs</span><span class=p>.</span><span class=n>show</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Note: when within the scope of the class body, you can use <code>MyContainer</code> and <code>MyContainer&lt;T></code> interchangeably. Essentially, you can consider <code>&lt;T></code> optional inside the class body. However, when outside the class scope (i.e. before the <code>::</code>), you have to fully qualify the name with <code>MyContainer&lt;T>::</code><ul><li>Once you specify the <code>::</code> in <code>MyContainer&lt;T>::</code>, you can imagine that youâ€™re basically re-entering the class scope, and then everything you could access within the class become available again.
<img src=/Knowledge/Engineering/Languages/assets/class-template-method-scope.png width=500>
(sourced from
<a href="https://www.youtube.com/watch?v=LMP_sxOaz6g&ab_channel=CppCon" rel=noopener>CppCon</a>)</li></ul></li></ul><a href=#aliases><h3 id=aliases><span class=hanchor arialabel=Anchor># </span>Aliases</h3></a><p>You can use <code>using</code> to create type aliases for template types.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>MyMap</span> <span class=o>=</span> <span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>T</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>MyMap</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>map</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>map</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=s>&#34;world&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>map</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=s>&#34;Goodbye&#34;</span><span class=p>,</span> <span class=s>&#34;world&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#concepts-todo><h3 id=concepts-todo><span class=hanchor arialabel=Anchor># </span>Concepts [TODO]</h3></a><p>Concepts are predicates that are used to apply constraints to the type arguments you pass to a template function or class. The main reason to use concepts is to get the compiler to be better at preventing misuage.</p><ul><li>This is from C++20. Prior to C++20, you&rsquo;d rely on [[Knowledge/Engineering/Languages/C++#Type Traits [TODO]|type traits]] with <code>static_assert</code>s, or simply trusting programmers to follow documentation on how to use a template correctly.</li><li>Useful concepts are provided in the
<a href=https://en.cppreference.com/w/cpp/concepts rel=noopener>standard <code>&lt;concepts></code> header</a>.</li></ul><p>TODO: notes on concept-based overloading, defining concepts.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=p>...</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>requires</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// The equivalent and less verbose way to use concepts without requirements clauses:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=p>...</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>You can overload template functions: depending on the type arguments, run a different generic algorithm.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=p>,</span> <span class=k>typename</span> <span class=n>U</span> <span class=o>=</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>concept</span> <span class=n>EqualityComparable</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>requires</span> <span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>U</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=n>a</span> <span class=o>==</span> <span class=n>b</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=n>a</span> <span class=o>!=</span> <span class=n>b</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=n>b</span> <span class=o>==</span> <span class=n>a</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span> <span class=n>b</span> <span class=o>!=</span> <span class=n>a</span> <span class=p>}</span> <span class=o>-&gt;</span> <span class=kt>bool</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static_assert</span><span class=p>(</span><span class=n>EqualityComparable</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>EqualityComparable</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>);</span>          
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>EqualityComparable</span><span class=o>&lt;</span><span class=kt>char</span><span class=o>&gt;</span><span class=p>);</span>          
</span></span><span class=line><span class=cl><span class=k>static_assert</span><span class=p>(</span><span class=n>EqualityComparable</span><span class=o>&lt;</span><span class=kt>char</span><span class=p>,</span> <span class=n>string</span><span class=o>&gt;</span><span class=p>);</span>  <span class=c1>// Fails.
</span></span></span></code></pre></td></tr></table></div></div><a href=#type-traits-todo><h3 id=type-traits-todo><span class=hanchor arialabel=Anchor># </span>Type Traits [TODO]</h3></a><a href=#deduction-guides-todo><h3 id=deduction-guides-todo><span class=hanchor arialabel=Anchor># </span>Deduction Guides [TODO]</h3></a><p>This is for aiding type inference.</p><a href=#functors><h2 id=functors><span class=hanchor arialabel=Anchor># </span>Functors</h2></a><p><em>Functors</em>, or <em>function objects</em>, are instances of a class that <strong>implements the function call operator method, <code>operator()</code></strong>, which means that they can invoked as if they were functions themselves. Functors are highly customisable, reusable, stateful functions.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>DrinkingLaw</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>DrinkingLaw</span><span class=p>(</span><span class=kt>int</span> <span class=n>required_age</span><span class=p>)</span> <span class=o>:</span> <span class=n>required_age_</span><span class=p>(</span><span class=n>required_age</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Implementing this method is what makes this class a functor
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>operator</span><span class=p>()(</span><span class=kt>int</span> <span class=n>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>age</span> <span class=o>&gt;=</span> <span class=n>required_age_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>required_age_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>DrinkingLaw</span> <span class=n>canDrink</span><span class=p>(</span><span class=mi>18</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;I can drink: &#34;</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>canDrink</span><span class=p>(</span><span class=mi>21</span><span class=p>)</span> <span class=o>?</span> <span class=s>&#34;Yup&#34;</span> <span class=o>:</span> <span class=s>&#34;Nope&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#lambda-functions><h3 id=lambda-functions><span class=hanchor arialabel=Anchor># </span>Lambda Functions</h3></a><p>You can think of lambda functions as syntactic sugar for <em>inline</em>, <em>anonymous <a href=/Knowledge/Engineering/Languages/C++#functors rel=noopener class=internal-link data-src=/Knowledge/Engineering/Languages/C++>functors</a></em>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=p>[</span><span class=n>_</span><span class=p>]</span> <span class=p>(</span><span class=n>params</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>RetType</span> <span class=p>{</span>   <span class=c1>// You can omit the return type if it can be inferred.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// Function body
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>You can use the capture clause (theÂ <code>[]</code>Â of the expression) to access variables from the outer scope.</p><ul><li><code>[&foo, bar]</code> â€” captures <code>foo</code> by reference and <code>bar</code> by value.</li><li><code>[&]</code> â€” capture all variables by reference.<ul><li><code>[&, foo]</code> â€” capture all variables by reference apart from <code>foo</code>, which is captured by value.</li></ul></li><li><code>[=]</code> â€” capture all variables by value.<ul><li><code>[=, &foo]</code> â€” capture all variables by value apart from <code>foo</code>, which is captured by reference.</li></ul></li></ul><p>A classic use of lambda functions is passing it as the comparator function to <code>std::sort</code> to determine whether one element comes before another.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>sort</span><span class=p>(</span><span class=n>v</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>v</span><span class=p>.</span><span class=n>end</span><span class=p>(),</span> <span class=p>[]</span> <span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>a</span> <span class=o>&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>val</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#enums><h2 id=enums><span class=hanchor arialabel=Anchor># </span>Enums</h2></a><p>In addition to structs and classes, you can also use enums to declare new data types. Enums are used to represent small sets of integer values in a readable way. There are two kinds of enums in C++, <em>plain enums</em> and <em>enum classes</em> (which are preferred over plain enums because of their type safety).</p><a href=#plain-enum><h3 id=plain-enum><span class=hanchor arialabel=Anchor># </span>Plain Enum</h3></a><p>Declared with just <code>enum</code>. The enum&rsquo;s values can be implicitly converted to integers</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=nc>Mood</span> <span class=p>{</span> <span class=n>happy</span><span class=p>,</span> <span class=n>sad</span><span class=p>,</span> <span class=n>nihilistic</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Mood</span> <span class=n>currMood</span> <span class=o>=</span> <span class=n>Mood</span><span class=o>::</span><span class=n>happy</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>currMood</span><span class=p>;</span>           <span class=c1>// No error, the Mood value is implicitly converted to an integer type.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#enum-class><h3 id=enum-class><span class=hanchor arialabel=Anchor># </span>Enum Class</h3></a><p>When you declare an enum with <code>enum class</code>, it is strongly typed such that you won&rsquo;t be able to assign an enum value to an integer variable or to another enum type. It reduces the number of &lsquo;surprises&rsquo; which is why it&rsquo;s preferred</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>Mood</span> <span class=p>{</span> <span class=n>happy</span><span class=p>,</span> <span class=n>sad</span><span class=p>,</span> <span class=n>nihilistic</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Mood</span> <span class=n>currMood</span> <span class=o>=</span> <span class=n>Mood</span><span class=o>::</span><span class=n>happy</span><span class=p>;</span>  
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>currMood</span><span class=p>;</span>            <span class=c1>// Error, Mood::happy is not an int.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#initialiser-list><h3 id=initialiser-list><span class=hanchor arialabel=Anchor># </span>Initialiser List</h3></a><p><code>std::initializer_list</code> is a special class whose objects are used to pass around a sequence of data using curly braces <code>{}</code> in a readable, intuitive way.</p><ul><li><code>std::initializer_list</code> is an <em>iterable</em>.</li><li>For some reason, you cannot subscript an instance of <code>std::initializer_list</code> like you would a vector or array (
<a href=https://stackoverflow.com/questions/17787394/why-doesnt-stdinitializer-list-provide-a-subscript-operator rel=noopener>SO discussion</a>).</li></ul><p>The compiler automatically converts <code>{ ... }</code> to an instantiation of <code>std::initializer_list</code> in these situations:</p><ol><li><code>{}</code> is used to construct a new object: <code>Person person{"Tim", "Zhang"}</code>
This will call the constructor of signature <code>Person(std::initializer_list&lt;string> l) {...}</code> <strong>if it exists</strong>. If such a constructor doesn&rsquo;t exist, it will look for <code>Person(string firstName, string lastName) { ... }</code>. So basically, it prefers invoking constructors that take in <code>std::initializer_list</code> but it will silently fall back to direct invocation if that fails.<ul><li>Constructors taking only one argument of this type are a special kind of constructor, calledÂ <em>initialiser-list constructor</em>.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>foo</span> <span class=p>{</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>};</span>  <span class=c1>// Calls the initialiser-list constructor. Calls `Foo(int, int)` if it doesn&#39;t exist.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>Foo</span> <span class=nf>bar</span> <span class=p>(</span><span class=mi>10</span><span class=p>,</span><span class=mi>20</span><span class=p>);</span>  <span class=c1>// Calls `Foo(int, int)`.
</span></span></span></code></pre></td></tr></table></div></div></li><li><code>{}</code> is used on the RHS of an assignment: <code>vector&lt;int> vec = { 1, 2, 4 };</code></li><li><code>{}</code> is bound to <code>auto</code>. E.g.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>i</span> <span class=p>:</span> <span class=p>{</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span> <span class=p>})</span>    <span class=c1>// `std::initializer_list` is an iterable.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>   
</span></span></code></pre></td></tr></table></div></div></li></ol><p>Interesting questions:</p><ul><li><a href=https://stackoverflow.com/questions/18164353/implementation-of-stdinitializer-list rel=noopener>It&rsquo;s not possible</a> to implement your own <code>std::initializer_list</code>. It&rsquo;s coupled to the language standard and the logic of the compiler, which you can&rsquo;t recreate through your own class.</li><li><a href=https://stackoverflow.com/questions/15198807/why-isnt-stdinitializer-list-a-language-built-in rel=noopener>Why isn&rsquo;t <code>std::initializer_list</code> built-in?</a></li></ul><a href=#iterators><h3 id=iterators><span class=hanchor arialabel=Anchor># </span>Iterators</h3></a><p>An iterator is an object that points to a specific item in a container. It has methods and operations for iterating over a container.</p><ul><li>To support range-based for loops, your class has to implement the <code>begin()</code> and <code>end()</code> methods and make them return an iterator.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>values</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;::</span><span class=n>iterator</span> <span class=n>it</span> <span class=o>=</span> <span class=n>values</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>values</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=n>it</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>it</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Syntactic sugar for the above:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nl>value</span> <span class=p>:</span> <span class=n>values</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>value</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>end()</code> isnâ€™t the last element, it points one position beyond the last element.</li><li>There is also:<ul><li><code>const_iterator</code> for read-only iteration.</li><li><code>reverse_iterator</code> for reverse iteration. Use it with <code>rbegin</code> and <code>rend</code></li></ul></li></ul><a href=#iterator-categories><h4 id=iterator-categories><span class=hanchor arialabel=Anchor># </span>Iterator Categories</h4></a><p>There are different types of iterators in C++, in order to least functionality to richest functionality:</p><ol><li><strong>Input iterator</strong> â€” you can only <em>access</em> the container in a single forward pass.</li><li><strong>Output iterator</strong> â€” you can only <em>assign</em> values to the container in a single forward pass.</li><li><strong>Forward iterator</strong> â€” combines input and output iterators.</li><li><strong>Bidirectional iterator</strong> â€” forward iterator that can also go back.</li><li><strong>Random access iterator</strong> â€” you can move the iterator anywhere, not just forward and back.</li></ol><p>They form a hierarchy where forward iterators contain all the functionality of input and output iterators, bidirectional contains all of forward, and random-access contains all of bidirectional:
<img src=/Knowledge/Engineering/Languages/assets/iterator-category-hierarchy.png width=400>
(sourced from
<a href=https://www.geeksforgeeks.org/ rel=noopener>GeeksForGeeks</a>)
<img src=/Knowledge/Engineering/Languages/assets/iterator-category-functionality-table.png width=600>
(sourced from
<a href=https://www.geeksforgeeks.org/ rel=noopener>GeeksForGeeks</a>)</p><p>The STL containers support different iterator categories:
<img src=/Knowledge/Engineering/Languages/assets/stl-container-iterator-type-supported.png width=500>
(sourced from
<a href=https://www.geeksforgeeks.org/ rel=noopener>GeeksForGeeks</a>)</p><a href=#random-c-features><h2 id=random-c-features><span class=hanchor arialabel=Anchor># </span>Random C++ Features</h2></a><p>Other important C++ details.</p><a href=#structured-bindings><h3 id=structured-bindings><span class=hanchor arialabel=Anchor># </span>Structured Bindings</h3></a><p>You can unpack values in C++17, similar to how you destructure objects in JavaScript. It&rsquo;s just syntactic sugar.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Coordinate</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>x</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=n>y</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Coordinate</span> <span class=n>point</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=p>[</span><span class=n>foo</span><span class=p>,</span> <span class=n>bar</span><span class=p>]</span> <span class=o>=</span> <span class=n>point</span><span class=p>;</span>   <span class=c1>// foo == 2, bar == 4
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>JavaScript calls this <em><strong>destructuring</strong></em>, Python calls this <em>unpacking</em>, C# calls this <em>deconstructing</em>.</li><li>Unfortunately, you have to specify as many identifiers as there are things to unpack.</li><li>Ranged for-loop:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;Hello&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=s>&#34;World&#34;</span><span class=p>,</span> <span class=mi>24</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=k>auto</span><span class=o>&amp;</span> <span class=p>[</span><span class=n>key</span><span class=p>,</span> <span class=n>val</span><span class=p>]</span> <span class=o>:</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Key: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>key</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, val: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>val</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li>Tuple destructuring:<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>tuple</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>tup</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>false</span><span class=p>,</span> <span class=mf>3.14</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>auto</span> <span class=p>[</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>,</span> <span class=n>z</span><span class=p>]</span> <span class=o>=</span> <span class=n>tup</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#using><h3 id=using><span class=hanchor arialabel=Anchor># </span>Using</h3></a><p>There are a few different ways the <code>using</code> keyword is used:</p><ol><li>Type aliasing (alternative to C-style <code>typedef</code>).
Itâ€™s generally more preferred to use <code>using</code> over C-style <code>typedef</code>. It also supports a little more extra functionality that is not available with <code>typedef</code>, specifically for templates.
<a href=https://stackoverflow.com/questions/10747810/what-is-the-difference-between-typedef-and-using-in-c11 rel=noopener>Source</a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// These two are (mostly) equivalent:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>using</span> <span class=n>Age</span> <span class=o>=</span> <span class=kt>unsigned</span> <span class=kt>int</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>typedef</span> <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>Age</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>typedef</code> is locally scoped. <code>using</code> makes the type alias available in the whole translation unit.</li></ul></li><li>Make an identifier from a namespace available in the current namespace.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li>Make <strong>all</strong> identifiers from a namespace available in the current namespace.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Avoid this as much as possible in large projects. It pollutes your namespace with lots of new identifiers.</li><li><code>using namespace</code> should never be used in header files because it forces the consumer of the header file to also bring in all those identifiers into their namespaces</li></ul></li><li>Lifting a parent class&rsquo; members into the current scope.<ul><li>Can be used to inherit constructors:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>D</span> <span class=o>:</span> <span class=k>public</span> <span class=n>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>using</span> <span class=n>C</span><span class=o>::</span><span class=n>C</span><span class=p>;</span>  <span class=c1>// Inherits all constructors from C.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=kt>void</span> <span class=nf>NewMethod</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div></li></ol><a href=#copy-elision><h3 id=copy-elision><span class=hanchor arialabel=Anchor># </span>Copy Elision</h3></a><p>By default, when you pass an object to a function, that object is copied over (pass-by-value). When it doesn&rsquo;t affect program behaviour, the compiler can move the object rather than making a full copy of it. This compiler optimisation can also happen when returning an object, throwing an exception, etc.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>str</span> <span class=o>=</span> <span class=s>&#34;Hello, world!&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>str</span><span class=p>;</span>  <span class=c1>// copy elision occurs here
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>string</span> <span class=n>s</span> <span class=o>=</span> <span class=n>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Note: in English/linguistics, to <em>elide</em> means to merge and therefore omit something in language. E.g. &ldquo;dunno&rdquo; == &ldquo;donâ€™t know&rdquo;.</li></ul><blockquote><p>Copy elision is not enforced in the C++ standard, so don&rsquo;t write code assuming this optimisation will happen.</p></blockquote><a href=#return-type-deduction><h3 id=return-type-deduction><span class=hanchor arialabel=Anchor># </span>Return Type Deduction</h3></a><p>In C++14, you can infer the return type of function whose return type is left as <code>auto</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>auto</span> <span class=nf>multiply</span><span class=p>(</span><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>b</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>a</span> <span class=o>*</span> <span class=n>b</span><span class=p>;</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>In <em>A Tour of C++</em>, Bjarne says to not overuse return type deductions.</p><a href=#initialiser-list-1><h3 id=initialiser-list-1><span class=hanchor arialabel=Anchor># </span>Initialiser List</h3></a><p>You can make a constructor or method take in an <code>std::initializer_list</code> to let the caller directly pass in a curly brace list like <code>{1, 2, 3, 4}</code> as an argument.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>values</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>Foo</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>elems</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=kt>int</span> <span class=o>&amp;</span><span class=nl>elem</span> <span class=p>:</span> <span class=n>elems</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>values</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>elem</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>foo</span><span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>initializer_list</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>elems</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=kt>int</span><span class=o>&amp;</span> <span class=nl>elem</span> <span class=p>:</span> <span class=n>elems</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Elem: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>elem</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>Foo</span> <span class=n>foo</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>};</span>
</span></span><span class=line><span class=cl>  <span class=n>foo</span><span class=p>.</span><span class=n>foo</span><span class=p>({</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>});</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>When the compiler sees something like <code>{1, 2, 3, 4}</code>, it will convert it to an instance of <code>std::initializer_list</code> (if used in a context like above).</p><a href=#casting-todo><h3 id=casting-todo><span class=hanchor arialabel=Anchor># </span>Casting [TODO]</h3></a><ul><li><code>static_cast</code> â€” casts from one type to another. <strong>It does not check what you&rsquo;re doing makes sense</strong>, so avoid using it often.</li><li><code>dynamic_cast</code> â€” casts pointer/reference types. Useful for runtime type-checking of objects. E.g. you can convert an instance of a parent class into an instance of a child class.<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>Parent</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Child</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Parent</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Parent</span><span class=o>*</span> <span class=n>foo</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Child</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>Child</span><span class=o>*</span> <span class=n>child</span> <span class=o>=</span> <span class=k>dynamic_cast</span><span class=o>&lt;</span><span class=n>Child</span><span class=o>*&gt;</span><span class=p>(</span><span class=n>foo</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;foo is a child.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Sometimes you have to use this, but do so sparingly.<blockquote><p>&ldquo;If we can avoid using type information, we can write simpler and more efficient code, but occasionally type information is lost and must be recovered. This typically happens when we pass an object to some system that accepts an interface specified by a base class. When that system later passes the object back to us, we might have to recover the original type.&rdquo; â€” Bjarne Stroustrup, A Tour of C++.</p></blockquote></li></ul></li><li><code>reinterpret_cast</code> â€” treating an object as a raw sequence of bytes.</li><li><code>const_cast</code> â€” casts away &lsquo;constness&rsquo;.</li><li><code>(type) value</code> â€” C-style typecasting. This is the least preferred way since it&rsquo;s unconstrained.</li></ul><a href=#inline-functions><h3 id=inline-functions><span class=hanchor arialabel=Anchor># </span>Inline Functions</h3></a><p><strong><code>inline</code> functions</strong>: when you want a function to be compiled such that the code is put <em>directly where it&rsquo;s called</em> instead of going through the overhead of entering a new function context, make that function <code>inline</code>.</p><p><strong>I.e. if you want the machine code to not have function calls to this function, put <code>inline</code></strong> before the function signature. This tells the compiler to place a copy of the function&rsquo;s code <em>at each point where the function is called</em> at compile time.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Inlining functions offers a marginal performance improvement (usually) because you avoid allocating a new <a href=/Knowledge/Engineering/Operating-Systems/Stack-Frame rel=noopener class=internal-link data-src=/Knowledge/Engineering/Operating-Systems/Stack-Frame>stack frame</a> thatâ€™s usually associated with making a function call.<ul><li>This performance improvement is done at the cost of a marginally bigger executable size since the code is now duplicated across potentially many places. Smaller functions are usually better candidates for inlining.</li><li><a href=https://softwareengineering.stackexchange.com/questions/254688/why-dont-compilers-inline-everything rel=noopener>Why not make everything inline?</a></li></ul></li></ul><a href=#if-statement-with-initialiser><h3 id=if-statement-with-initialiser><span class=hanchor arialabel=Anchor># </span>if-statement With Initialiser</h3></a><p>In C++17, you can declare variables inside <code>if</code> statements and follow it up with a condition: <code>if (init; condition) { ... }</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vector size is not 0&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>size</span> <span class=o>&gt;</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Vector size is &gt; 2&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#noexcept-conditions><h3 id=noexcept-conditions><span class=hanchor arialabel=Anchor># </span>Noexcept Conditions</h3></a><ul><li><strong><code>noexcept(false)</code></strong>: it&rsquo;s possible to use <code>noexcept(false)</code> in function signatures to say that &rsquo;this function throws no exceptions (but it actually might, lol)&rsquo;. Just avoid using it.</li><li><strong><code>noexcept(true)</code></strong> and <code>noexcept</code> are completely equivalent.</li><li><strong><code>throw()</code></strong>: in older C++, you can put <code>throw()</code> at the end of a function signature to say that the function never throws exceptions, for example: <code>void something_bad() throw()</code>. It&rsquo;s been deprecated by <code>noexcept</code> in C++11, which is preferred over <code>throw()</code>, so you&rsquo;d do: <code>void something_bad() noexcept</code> instead.</li></ul><a href=#aggregates><h3 id=aggregates><span class=hanchor arialabel=Anchor># </span>Aggregates</h3></a><p><em>Aggregates</em> are either arrays or structs/classes that you didn&rsquo;t define constructors, private/protected instance variables or virtual methods for. When those conditions are met, that class is an <em>aggregate</em> type and can be initialised with <code>{}</code>.</p><ul><li>The order that you declare the fields matter.</li></ul><blockquote><p>Even though they both use <code>{}</code>, <strong><em>aggregate initialisation</em> is different from <em>list initialisation</em></strong>!</p></blockquote><a href=#pods><h4 id=pods><span class=hanchor arialabel=Anchor># </span>PODs</h4></a><p><em>PODs</em> (<em>Plain Old Data</em>) are a kind of <em>aggregate type</em> that do not overload <code>operator=</code>, have no destructor, and there are no non-static members that are: non-POD classes, arrays of non-POD classes, or references.
<a href=https://stackoverflow.com/questions/4178175/what-are-aggregates-and-pods-and-how-why-are-they-special rel=noopener>Learn more</a>.</p><p>Put simply, PODs are just simple data, or simple data containers, hence the name &lsquo;plain old data&rsquo;.</p><ul><li><strong>They&rsquo;re very similar to structs in C</strong>.</li><li>Because they&rsquo;re very simple, using PODs can offer performance advantages because the compiler no longer needs to set up the same abstractions necessary for normal classes to work, letting them generate more efficient code.</li><li>Many built-in types are PODs, such as <code>int</code>, <code>double</code>, <code>enums</code>, etc.</li></ul><a href=#protected-and-private-inheritance><h3 id=protected-and-private-inheritance><span class=hanchor arialabel=Anchor># </span>Protected and Private Inheritance</h3></a><p>Protected and private inheritance are specific to C++. Other languages usually won&rsquo;t have this.</p><blockquote><p>Just default to using public inheritance (<code>: public</code>) if you want to represent an <em>is-a</em> relationship. Use protected and private inheritance sparingly.</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PublicChild</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// a is public.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// b is protected.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// c is inaccessible here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ProtectedChild</span> <span class=o>:</span> <span class=k>protected</span> <span class=n>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// a is protected.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// b is protected.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// c is inaccessible here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>PrivateChild</span> <span class=o>:</span> <span class=k>private</span> <span class=n>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// a is private.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// b is private.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// c is inaccessible here.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Protected inheritance makes all public members inherited from the parent protected.</li><li>Private inheritance makes all public and protected members inherited from the parent private. Private inheritance basically hides the inheritance from the rest of the world.</li></ul><a href=#class-prototypes><h3 id=class-prototypes><span class=hanchor arialabel=Anchor># </span>Class Prototypes</h3></a><p>Class prototypes are just like function prototypes. You can declare all your classes upfront and then use them wherever you want throughout the code.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Declare classes.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>A</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Define classes later (any order is okay).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>B</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span> <span class=p>{</span> <span class=p>...</span> <span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#user-defined-literals><h3 id=user-defined-literals><span class=hanchor arialabel=Anchor># </span>User-Defined Literals</h3></a><p>It&rsquo;s possible to define custom literals that improve readability. E.g. <code>&lt;chrono></code> makes it possible to write: <code>24h</code>, <code>42min</code>, etc. directly.</p><p>Example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>constexpr</span> <span class=kt>int</span> <span class=k>operator</span><span class=s>&#34;&#34;</span><span class=n>min</span><span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>60</span> <span class=o>*</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Seconds: &#34;</span> <span class=o>&lt;&lt;</span> <span class=mi>42</span><span class=n>min</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#thread_local><h3 id=thread_local><span class=hanchor arialabel=Anchor># </span>thread_local</h3></a><p>There is a <code>thread_local</code> keyword in C++. When a variable is declared with <code>thread_local</code>, it is brought into existence when the thread starts and deallocated when the thread ends. In that sense, the thread sees that variable as a <em>static</em> variable since it exists throughout its lifetime.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>thread_local</span> <span class=kt>int</span> <span class=n>myInt</span> <span class=o>=</span> <span class=p>...;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#unnamed-scopes><h3 id=unnamed-scopes><span class=hanchor arialabel=Anchor># </span>Unnamed Scopes</h3></a><p>Usually, we use <code>{}</code> to define scopes for functions, classes, if-blocks, for-loops, etc., but you can also just use them directly in code to create a restricted scope.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>   <span class=c1>// Start of an unnamed scope.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// A smaller scope containing some statements
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>   
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Doing this within a function is useful when you want a destructor to be called as soon as possible. E.g. often when dealing with mutexes, youâ€™d want to acquire and release a lock as soon as possible.</li></ul><a href=#union><h3 id=union><span class=hanchor arialabel=Anchor># </span>Union</h3></a><p>A <code>union</code> is data structure like a <code>class</code> or <code>struct</code>, except all its members share the same memory address, meaning it can only hold 1 value for one member at a time. The implication is that a union can only hold <strong>one value at a time</strong>, and its total allocated memory is equal to $\texttt{max(sizeof each member)}$.</p><ul><li>Itâ€™s mainly used when you <em>really</em> need to conserve memory.</li><li>Theyâ€™re mostly useless in C++ but more useful in C.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>union</span> <span class=nc>Numeric</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span>  <span class=n>sVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span>    <span class=n>iVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>dVal</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Unions&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Numeric</span> <span class=n>num</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>42</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>.</span><span class=n>sVal</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// Prints 42.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>.</span><span class=n>iVal</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// Prints 42.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>num</span><span class=p>.</span><span class=n>dVal</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>    <span class=c1>// Interprets the bits of 42 using floating point representation (IEEE 754).
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#compile-time-if-todo><h3 id=compile-time-if-todo><span class=hanchor arialabel=Anchor># </span>Compile-Time If [TODO]</h3></a><p><code>if constexpr() { ... }</code>. C++17.</p><a href=#volatile-todo><h3 id=volatile-todo><span class=hanchor arialabel=Anchor># </span>Volatile [TODO]</h3></a><a href=#extern><h3 id=extern><span class=hanchor arialabel=Anchor># </span>Extern</h3></a><p>From what I understand, <code>extern int foo</code> is basically saying &ldquo;trust me compiler, there&rsquo;s an int called foo that is defined somewhere.&rdquo;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// main.cc
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// `foo` exists, but its value is defined in some other file. Trust me, compiler.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>extern</span> <span class=kt>int</span> <span class=n>foo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>foo</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// foo.cc â€” there is literally just this one line in this file.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>foo</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>    
</span></span></code></pre></td></tr></table></div></div><p>Compiling the above with <code>g++ -o main main.cc foo.cc</code> and it just works.</p><a href=#fold-expressions-todo><h3 id=fold-expressions-todo><span class=hanchor arialabel=Anchor># </span>Fold Expressions [TODO]</h3></a><a href=#appendix><h1 id=appendix><span class=hanchor arialabel=Anchor># </span>Appendix:</h1></a><p>All the notes under this section are meant to be topics or details you donâ€™t need to care much about to program effectively with C++.</p><a href=#c-compilation-todo><h3 id=c-compilation-todo><span class=hanchor arialabel=Anchor># </span>C++ Compilation [TODO]</h3></a><p>Compilation of C++ programs follow 3 steps:</p><ol><li><strong>Preprocessing</strong>
Preprocessor directives like <code>#include</code>, <code>#define</code>, <code>#if</code>, etc. transforms the code before any compilation happens. At the end of this step, a pure C++ file is produced.</li><li><strong>Compilation</strong>
The compiler (eg. g++, the GNU C++ compiler) takes in pure C++ source code and produces an object file. This step doesnâ€™t produce anyting that the user can actually run â€” it just produces the machine language instructions.</li><li><strong>Linking</strong>
Takes object files and produces a library or executable file that your OS can use.</li></ol><a href=#commenting><h3 id=commenting><span class=hanchor arialabel=Anchor># </span>Commenting</h3></a><p>The advice here is sourced from
<a href=https://google.github.io/styleguide/cppguide.html rel=noopener>Googleâ€™s C++ style guide</a>.</p><a href=#file-comments><h4 id=file-comments><span class=hanchor arialabel=Anchor># </span>File Comments</h4></a><p>File comments are preferred but not always necessary. Function and class documentation, on the other hand, must be present with exceptions only for trivial cases.</p><ul><li>Start with licence boilerplate, then broadly describe what abstractions are introduced by the file.</li><li>Donâ€™t duplicate comments across a classâ€™ <code>.h</code> and <code>.cc</code> file.
<a href=https://github.com/google/googletest/blob/main/googletest/src/gtest-all.cc rel=noopener>Example</a></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Copyright 2008, Google Inc.
</span></span></span><span class=line><span class=cl><span class=c1>// All rights reserved.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Redistribution and use in source and binary forms, with or without
</span></span></span><span class=line><span class=cl><span class=c1>// modification, are permitted
</span></span></span><span class=line><span class=cl><span class=c1>// ... and so on
</span></span></span><span class=line><span class=cl><span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1>// Google C++ Testing and Mocking Framework (Google Test)
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// Sometimes it&#39;s desirable to build Google Test by compiling a single file.
</span></span></span><span class=line><span class=cl><span class=c1>// This file serves this purpose.
</span></span></span></code></pre></td></tr></table></div></div><a href=#variable-comments><h4 id=variable-comments><span class=hanchor arialabel=Anchor># </span>Variable Comments</h4></a><p>Generally not required if the name is sufficiently descriptive. Often for class variables, more context is needed to explain the purpose of the variable.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	 <span class=c1>// Used to bounds-check table accesses. -1 means
</span></span></span><span class=line><span class=cl><span class=c1></span>	 <span class=c1>// that we don&#39;t yet know how many entries the table has.
</span></span></span><span class=line><span class=cl><span class=c1></span>	 <span class=kt>int</span> <span class=n>num_total_entries_</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#todo-comments><h4 id=todo-comments><span class=hanchor arialabel=Anchor># </span>TODO Comments</h4></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// TODO(kl@gmail.com): Use a &#34;*&#34; here for concatenation operator.
</span></span></span><span class=line><span class=cl><span class=c1>// TODO(Zeke) change this to use relations.
</span></span></span><span class=line><span class=cl><span class=c1>// TODO(bug 12345): remove the &#34;Last visitors&#34; feature.
</span></span></span></code></pre></td></tr></table></div></div><a href=#function-comments><h4 id=function-comments><span class=hanchor arialabel=Anchor># </span>Function Comments</h4></a><p>Always write a comment to explain what the function/method accomplishes unless it is trivial. This includes private functions.</p><ul><li>Start with a verb. Eg. â€œOpens a file&mldr;â€ or â€œReturns an iterator for&mldr;â€</li><li>Which arguments can be <code>nullptr</code> and what that would mean.</li><li>Performance implications of how the function is used.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Returns an iterator for this table, positioned at the first entry
</span></span></span><span class=line><span class=cl><span class=c1>// lexically greater than or equal to `start_word`. If there is no
</span></span></span><span class=line><span class=cl><span class=c1>// such entry, returns a null pointer. The client must not use the
</span></span></span><span class=line><span class=cl><span class=c1>// iterator after the underlying GargantuanTable has been destroyed.
</span></span></span><span class=line><span class=cl><span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1>// This method is equivalent to:
</span></span></span><span class=line><span class=cl><span class=c1>//    std::unique_ptr&lt;Iterator&gt; iter = table-&gt;NewIterator();
</span></span></span><span class=line><span class=cl><span class=c1>//    iter-&gt;Seek(start_word);
</span></span></span><span class=line><span class=cl><span class=c1>//    return iter;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Iterator</span><span class=o>&gt;</span> <span class=n>GetIterator</span><span class=p>(</span><span class=n>absl</span><span class=o>::</span><span class=n>string_view</span> <span class=n>start_word</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#class-comments><h4 id=class-comments><span class=hanchor arialabel=Anchor># </span>Class Comments</h4></a><p>Always write a comment to explain what the classâ€™ purpose is and when to correctly use it. Always do this in the <code>.h</code> file, leaving comments about implementation detail to the implementing <code>.cc</code> file.</p><ul><li>Good place to provide a code snippet illustrating a simple use case.</li><li>About documenting the <code>.h</code> header file vs. documenting the <code>.cc</code> source file<ul><li>Document how to use the function in the header file, or more accurately close to the declaration</li><li>Document how the function works (if it&rsquo;s not obvious from the code) in the source file, or more accurately, close to the definition
<a href=https://softwareengineering.stackexchange.com/questions/84071/is-it-better-to-document-functions-in-the-header-file-or-the-source-file rel=noopener>Source</a>.</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Iterates over the contents of a GargantuanTable.
</span></span></span><span class=line><span class=cl><span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1>// Example:
</span></span></span><span class=line><span class=cl><span class=c1>//    std::unique_ptr&lt;GargantuanTableIterator&gt; iter = table-&gt;NewIterator();
</span></span></span><span class=line><span class=cl><span class=c1>//    for (iter-&gt;Seek(&#34;foo&#34;); !iter-&gt;done(); iter-&gt;Next()) {
</span></span></span><span class=line><span class=cl><span class=c1>//        process(iter-&gt;key(), iter-&gt;value());
</span></span></span><span class=line><span class=cl><span class=c1>//    }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>GargantuanTableIterator</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	  <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><a href=#flashcards><h1 id=flashcards><span class=hanchor arialabel=Anchor># </span>Flashcards</h1></a><p>Some simple Q-and-A notes to be used as flashcards.</p><ul><li>What is separate compilation?<ul><li>A division of a larger project into smaller units that interact with each other through header files. One unit only knows about another unit through their header files. The big benefit of structuring projects this way is to allow for compilation to be done independently on these units, meaning that if one unit changes while others have not, then only that one unit is to be compiled.</li></ul></li><li>What are the differences between copy, list and direct initialisation?<ul><li>They&rsquo;re the 3 ways initialisation of a new variable is done in C++. Copy initialisation is done with <code>=</code>, list initialisation is done with <code>{}</code>, and direct initialisation is done with <code>()</code>. Copy initialisation invokes the . Direct initialisation is directly invoking the constructor, hence the use of <code>()</code>.</li></ul></li><li>What is the difference between <code>const</code> and <code>constexpr</code>?</li><li>What happens when an identifier is declared outside of a namespace?<ul><li>That identifier becomes globally scoped, i.e. part of the global namespace. It can be referenced directly or with <code>::</code> to explicitly say it&rsquo;s from the global namespace.</li></ul></li><li>Explain RAII and what problem it aims to solve.<ul><li><em>Resource allocation is initialisation</em> means that any resources (things like file handles, database handles, etc.) required by a class should be acquired in the constructor and then released in the destructor. Think of it as &ldquo;scope-bound resource management&rdquo;. The point here is that when a class throws an exception or goes out of scope, the destructor is called, guaranteeing no resources to be held after the object&rsquo;s lifetime.</li></ul></li><li>What are designated initialisers in C++? How do you use them?</li><li>How do you define a custom exception in C++?<ul><li>Write a new class that inherits from <code>std::exception</code> and implement the <code>const char* what() const throw()</code> method and implement a constructor that takes in an error message.</li></ul></li><li>Explain copy elision.</li><li>What problem does a move constructor solve â€” when would you use one?</li><li>What is a const method and why would you use it?<ul><li>A const method is one where <code>const</code> is placed at the end of the function signature. It basically says the method will not modify whatever <code>this</code> is. As a caller of a const method, you can trust it won&rsquo;t mutate the object it was called on (although you still can&rsquo;t be 100% certain because the <code>mutable</code> keyword exists, which lets the const method mutate specific fields anyway, and there are other ways even without the <code>mutable</code> keyword, I think).</li></ul></li><li>When would you write a function that has a <code>const</code> return type?<ul><li>Pretty much never.</li></ul></li><li>What are inline functions? Why would you use them?</li><li>What are aggregate types? What are POD types?</li><li>Explain the differences between classes and structs.<ul><li>They&rsquo;re basically the same, except the members in classes are private by default whereas the members in structs are public by default. Note that this difference is only for C++. In C# which also has classes and structs, the structs are also <em>value types</em>, meaning that they&rsquo;re passed-by-value instead of by reference.</li></ul></li><li>Explain lvalues and rvalues.</li><li>Explain what the access modifiers do in inheritance.</li><li>How do you make a class abstract in C++?<ul><li>Give it at least one pure virtual function. E.g. <code>virtual void foo() = 0;</code>.</li></ul></li><li>What are the differences between virtual functions and pure virtual functions? How does this differ between C++ and other languages like C# or Java?<ul><li>Virtual functions are those that <em>can</em> be overridden. Pure virtual functions are those that <em>must</em> be overridden. In other languages like C#, all methods are virtual by default. In those languages, pure virtual functions are known as <em>abstract functions</em>.</li></ul></li><li>How do you use <code>override</code> in C++? What&rsquo;s the point?</li><li>Why is the output of the following program &ldquo;Something&rdquo;?<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=k>virtual</span> <span class=kt>void</span> <span class=n>do_something</span><span class=p>()</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Something</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>Child</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Parent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>      <span class=kt>void</span> <span class=n>do_something</span><span class=p>()</span> <span class=k>override</span> <span class=p>{</span> <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Overridden</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>Parent</span> <span class=n>foo</span> <span class=o>=</span> <span class=n>Child</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=n>foo</span><span class=p>.</span><span class=n>do_something</span><span class=p>();</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>If this code were written in Java, the output would be &ldquo;Overridden&rdquo;. In C++, we have <em>object slicing</em>. If you wanted to get this C++ to output &ldquo;Overridden&rdquo;, you&rsquo;d have to use pointer types or references.</li></ul></li><li>Explain 3 ways the <code>delete</code> keyword is used.<ul><li>Deleting memory-allocated objects: <code>delete obj;</code>, deleting arrays: <code>delete[] my_arr;</code>, declaring deleted functions <code>void foo() = delete;</code>. Deleted functions are mainly used to suppress operations and constructors, mainly. E.g. you&rsquo;d mark an overloaded operator method as deleted to prevent the misuse of it.</li></ul></li><li>Explain const objects.<ul><li>Object variables declared with the <code>const</code> qualifier</li></ul></li><li>What are the uses for <code>final</code>?<ul><li>It can be used to declare final methods and final classes. Final methods can&rsquo;t be overridden or changed by child classes. They&rsquo;re declared like this: <code>void foo() final;</code>. Final classes cannot be inherited. They&rsquo;re declared like this: <code>class Foo final;</code> .</li></ul></li><li>Explain <code>friend</code> in C++ â€” what do they do and how do you use it?<ul><li>Inside class <code>Foo</code>, use <code>friend class Bar</code> to grant <code>Bar</code> access to every member of <code>Foo</code>. &ldquo;Friends can touch your privates,&rdquo; and &ldquo;you can&rsquo;t grant yourself access to other people&rsquo;s privates, but you can grants others access to yours&rdquo;. It&rsquo;s use is discouraged, but sometimes it&rsquo;s helpful for unit testing classes to access private methods.</li></ul></li><li>Explain lvalue and rvalue references.</li><li>Write a valid function signature for: a copy constructor, copy assignment operator overload, move constructor and move assignment operator overload.<ul><li><code>Foo(const Foo& other)</code>, <code>Foo& operator=(const Foo& other)</code>, <code>Foo(Foo&& other)</code>, <code>Foo& operator=(Foo&& other)</code>.</li></ul></li><li>What is std::move?<ul><li>It&rsquo;s a function you use to help you invoke the move constructor or the move assignment operator. It converts an lvalue to an rvalue reference. It doesn&rsquo;t do any actual moving itself.</li></ul></li><li>What&rsquo;s <code>thread_local</code>?</li><li>How do you define a function template?</li><li>How do you define a class template? How do you define the methods of a class template outside of the class definition?</li><li>What are value arguments in template definitions?<ul><li>You can make function or class templates take in a value in addition to type arguments. E.g. <code>template &lt;typename T, int N></code>.</li></ul></li><li>What are functors?<ul><li>Functors are also called <em>function objects</em>.</li></ul></li><li>How are functors and lambda functions related?<ul><li>Lambda functions are basically anonymous functors.</li></ul></li><li>In lambda expression <code>[&, foo] () { ... }</code>, what does <code>[&, foo]</code> mean?<ul><li>It&rsquo;s a capture group, which is a list of identifiers from the containing scope that should be accessible within the function body. The <code>[&, foo]</code> means that all identifiers should be accessible by reference, except for <code>foo</code> which should be copied.</li></ul></li><li>What&rsquo;s the difference between plain enums and enum classes? Which one should you generally prefer?</li><li>What is the <code>extern</code> keyword in C++?</li><li>What is the type of <code>foo</code> here? <code>auto foo = { 10, 20, 30 };</code></li><li>What&rsquo;s different about switch-case statements in C++ compared to other languages?<ul><li>You have to wrap each case in curly braces. E.g. <code>case foo: { ... }</code>.</li></ul></li><li>Should you always use range-based for loops?<ul><li>In general yes, but with exceptions. Eg. you should not use it when you are erasing values, inserting something into the middle of something, etc., basically anytime you need to manipulate the position of the iterator, youâ€™d have to fall back to the ugly for loop.</li></ul></li><li>What are the 5 main iterator categories? How do they relate to each other?<ul><li>They are: input, output, forward, bidirectional, random access.</li></ul></li><li>Why should I use <code>make_unique</code> to create <code>unique_ptr</code>s instead of directly constructing them using <code>new</code> like in: <code>unique_ptr&lt;Foo>(new Foo(...))</code>?<ul><li>It&rsquo;s exception safe, meaning if <code>foo(unique_ptr&lt;X>(new X), unique_ptr&lt;Y>(new Y))</code> fails, there are no resource leaks. It avoids usage of <code>new</code> and <code>delete</code>, which is always recommended for modern C++ code. It&rsquo;s more readable since you specify <code>Foo</code> only once compared to twice: <code>make_unique&lt;Foo></code>.</li></ul></li><li>Explain the difference between <code>unique_ptr</code> and <code>shared_ptr</code>.<ul><li><code>unique_ptr</code> represents sole ownership while <code>shared_ptr</code> represents shared ownership. A <code>unique_ptr</code> deletes the object it&rsquo;s hosting once it goes out of scope. A <code>shared_ptr</code> does the same only if it is the last remaining owner of the object it&rsquo;s hosting. The copy constructor and assignment operator are disabled in <code>unique_ptr</code> and only allows for move semantics. In <code>shared_ptr</code>, copy and move are enabled.</li></ul></li></ul><a href=#questions><h2 id=questions><span class=hanchor arialabel=Anchor># </span>Questions</h2></a><p>Some questions I have that are answered:</p><ul><li>Why use functors over methods? From what I know, the main purpose of functors is to act as stateful functions. Methods can clearly accomplish the same purpose.</li><li>Why use regular array literal with <code>[]</code> vs using <code>std::array</code>?</li></ul></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/ data-ctx=C++ data-src=/ class=internal-link>Tim's Dev Wiki</a></li><li><a href=/Knowledge/Engineering/Languages/Go/ data-ctx=C++ data-src=/Knowledge/Engineering/Languages/Go class=internal-link>Go</a></li><li><a href=/Knowledge/Engineering/Programming/AOT/ data-ctx=C++ data-src=/Knowledge/Engineering/Programming/AOT class=internal-link>AOT</a></li><li><a href=/Knowledge/Engineering/Programming/Object-Oriented-Programming/ data-ctx="pure virtual function" data-src=/Knowledge/Engineering/Programming/Object-Oriented-Programming class=internal-link>Object Oriented Programming</a></li></ul></div></div><div id=contact_buttons><footer><ul><li><a href=/>Home</a></li><li><a href=https://timz.dev>timz.dev</a></li><li><a href=https://github.com/Tymotex/wiki>Github</a></li><li><a href=https://www.linkedin.com/in/timz-seng>LinkedIn</a></li></ul><p>Tim Zhang Â© 2023</p></footer></div></div></body></html>