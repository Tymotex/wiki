<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="This section contains notes about some of the most useful things from the std namespace. The C++ standard library also contains the entire C standard library, each header being available through <c*>, e."><title>C++ Standard Library</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://wiki.timz.dev//icon.png><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Source+Sans+Pro:wght@400;600;700&family=Fira+Code:wght@400;700&display=swap" rel=stylesheet><link href=https://wiki.timz.dev/styles.f0166864fd6bb1603db547f1f970f84b.min.css rel=stylesheet><link href=https://wiki.timz.dev/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://wiki.timz.dev/js/darkmode.773d76aedcd615c64f644f542d60cb1b.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script src=https://wiki.timz.dev/js/popover.688c5dcb89a57776d7f1cbeaf6f7c44b.min.js></script>
<script src=https://wiki.timz.dev/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://wiki.timz.dev/js/clipboard.de8d8b2221fe27323078cbd76188e364.min.js></script>
<script>const BASE_URL="https://wiki.timz.dev/",fetchData=Promise.all([fetch("https://wiki.timz.dev/indices/linkIndex.6ddf5c9ea243586bf83f3cff62b284c1.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://wiki.timz.dev/indices/contentIndex.22ccfb4b093ee2bbaa0b518a773e333a.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const n=new URL(BASE_URL),s=n.pathname,o=window.location.pathname,i=s==o;addCopyButtons();const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=i&&!0;drawGraph("https://wiki.timz.dev",t,[{"/Knowledge/Engineering":"#4388cc"},{"/Knowledge/Investing":"#98c379"},{"/Knowledge/Personal-Finance":"#98c379"},{"/Knowledge/Finance":"#FFD700"},{"/Knowledge/Economics":"#FFD700"}],t?{centerForce:1,depth:3,enableDrag:!0,enableLegend:!0,enableZoom:!0,fontSize:.4,linkDistance:1,opacityScale:3,repelForce:.2,scale:1.4}:{centerForce:1,depth:2,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:1,scale:3}),initPopover("https://wiki.timz.dev",!0,!0)},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],throwOnError:!1})}</script><script>window.Million={navigate:e=>window.location.href=e,prefetch:()=>{}},window.addEventListener("DOMContentLoaded",()=>{init(),render()})</script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script src=https://cdn.jsdelivr.net/npm/flexsearch@0.7.21/dist/flexsearch.bundle.js integrity="sha256-i3A0NZGkhsKjVMzFxv3ksk0DZh3aXqu0l49Bbh0MdjE=" crossorigin=anonymous defer></script>
<script defer src=https://wiki.timz.dev/js/search.cf33b507388f3dfd5513a2afcda7af41.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://wiki.timz.dev/js/graph.0ac96ed5ea296a8b1ac03a6eba11878c.js></script><div class=singlePage><header><h1 id=page-title><a href=https://wiki.timz.dev/>🌱 Tim's Dev Wiki</a></h1><svg tabindex="0" id="search-icon" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg><div class=spacer></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>C++ Standard Library</h1><p class=meta>Last updated December 28, 2022.</p><ul class=tags></ul><aside class=mainTOC><details open><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#string-todo><code>&lt;string></code> [TODO]</a></li></ol><ol><li><a href=#vector><code>&lt;vector></code></a></li><li><a href=#set><code>&lt;set></code></a></li><li><a href=#unordered_set><code>&lt;unordered_set></code></a></li><li><a href=#map><code>&lt;map></code></a></li><li><a href=#unordered_map><code>&lt;unordered_map></code></a></li><li><a href=#array><code>&lt;array></code></a></li><li><a href=#stack><code>&lt;stack></code></a></li><li><a href=#queue><code>&lt;queue></code></a></li><li><a href=#tuple><code>&lt;tuple></code></a></li></ol><ol><li><ol><li><a href=#ostream><code>ostream</code></a></li><li><a href=#iomanip-todo><code>iomanip</code> [TODO]</a></li><li><a href=#istream><code>istream</code></a></li></ol></li><li><a href=#file-manipulation-fstream>File Manipulation (<code>fstream</code>)</a></li><li><a href=#string-streams-sstream>String Streams (<code>sstream</code>)</a></li><li><a href=#filesystem>Filesystem</a></li></ol><ol><li><a href=#memory-1><code>&lt;memory></code></a><ol><li><a href=#unique_ptr><code>unique_ptr</code></a></li><li><a href=#shared_ptr><code>shared_ptr</code></a></li><li><a href=#weak_ptr-todo><code>weak_ptr</code> [TODO]</a></li></ol></li></ol><ol><li><a href=#thread><code>&lt;thread></code></a></li><li><a href=#mutex><code>&lt;mutex></code></a></li><li><a href=#future-todo><code>&lt;future></code> [TODO]</a><ol><li><a href=#async-todo><code>async</code> [TODO]</a></li></ol></li></ol><ol><li><a href=#regex><code>&lt;regex></code></a></li></ol></nav></details></aside><p>This section contains notes about some of the most useful things from the <code>std</code> namespace. The C++ standard library also contains the <em>entire C standard library</em>, each header being available through <code>&lt;c*></code>, e.g. <code>&lt;cstdlib></code>, which in C is equivalent to <code>&lt;stdlib.h></code>, and <code>&lt;cmath></code>, which in C is equivalent to <code>&lt;math.h></code>.</p><p>See all
<a href=https://en.cppreference.com/w/cpp/header rel=noopener>C++ Standard Library headers</a>.</p><a href=#string-todo><h2 id=string-todo><span class=hanchor arialabel=Anchor># </span><code>&lt;string></code> [TODO]</h2></a><p>There is no built-in string type in C++, but the standard library provides <code>std::string</code> in <code>&lt;string></code>. Note that string literals on the other hand are part of the language itself, their data type is <code>const char*</code>.</p><p>The set of methods available to the <code>std::string</code> class is similar to the methods available to <code>std::vector</code>, plus a few more special string manipulation methods and operator support like <code>+</code>, <code>&lt;&lt;</code>, <code>>></code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Main operations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s1</span> <span class=o>+</span> <span class=n>s2</span>              <span class=c1>// Concatentation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s1</span><span class=p>.</span><span class=n>append</span><span class=p>(</span><span class=n>s2</span><span class=p>)</span>        <span class=c1>// Alternative to + operator
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// TODO: https://www.cplusplus.com/reference/string/string/compare/
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s1</span><span class=p>.</span><span class=n>compare</span><span class=p>(</span><span class=n>s2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s1</span><span class=p>.</span><span class=n>compare</span><span class=p>(</span><span class=n>s2</span><span class=p>,</span> <span class=n>pos</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>startPos</span><span class=p>,</span> <span class=n>runLen</span><span class=p>)</span>   <span class=c1>// Returns the substring from inclusive startPos onwards for runLen characters
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>//TODO: more string ops https://www.cplusplus.com/reference/string/string/
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>find</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>find_first_of</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>find_first_not_of</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>find_last_of</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>find_last_not_of</span>
</span></span><span class=line><span class=cl><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=c1>// Others
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>copy</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>isdigit</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>    <span class=c1>// Returns true if the string consists of a valid digit.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>isalnum</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>isspace</span><span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>Raw Strings:</p><p>There are raw string literals just like in Python where everything inside the string is treated as raw characters, not special characters. This means you won’t have to escape any special characters with backslash and they’ll all lose their meaning. This is especially useful when defining strings containing regex patterns which contain a bunch of backslashes.</p><p>The format for defining a raw string literal is: $\texttt{R"(&mldr;)"}$.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>my_raw_str</span> <span class=o>=</span> <span class=n>R</span><span class=s>&#34;(my raw string)&#34;</span><span class=p>;</span>   <span class=c1>// → &#34;my raw string&#34;
</span></span></span></code></pre></td></tr></table></div></div><ul><li>String formatting with <code>std::stringstream</code> from <code>&lt;sstream></code><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>stringstream</span> <span class=n>fmt</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>fmt</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;hello &#34;</span> <span class=o>&lt;&lt;</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>formatted_str</span> <span class=o>&lt;&lt;</span> <span class=n>fmt</span><span class=p>.</span><span class=n>str</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><p>str.find_first_of</p><p>std::string::npos</p><p>std::string_view vs std::string</p><ul><li><p>A <code>string_view</code> is nothing but a pointer to a string and a length. It serves as basically a read-only substring of an underlying string.</p></li><li><p><code>string_view</code> can offer better performance than <code>string</code>.</p></li><li><p><a href=https://stackoverflow.com/questions/40127965/how-exactly-is-stdstring-view-faster-than-const-stdstring rel=noopener>Why not just use <code>const string&</code>?</a> Because that <em>has</em> to refer to a <code>std::string</code> exactly, not a char array, <code>const char*</code>, <code>vector&lt;char></code> etc., which means that a new <code>std::string</code> instance must be created from these other &lsquo;sequence of char&rsquo; formats, which is potentially expensive.</p></li><li><p>You can do <code>constexpr std::string_view s = "…"</code>, but not <code>constexpr std::string s = "…"</code></p></li><li><p>You can get string literals of type <code>std::string</code> by suffixing a regular string literal with <code>s</code>, e.g. <code>"Hello"s</code>.</p></li><li><p>You can get <code>string_view</code> literals by suffixing string literals with <code>sv</code>, e.g. <code>"Hello"sv</code>.</p></li></ul><a href=#stl-containers><h1 id=stl-containers><span class=hanchor arialabel=Anchor># </span>STL Containers</h1></a><p>The STL (standard template library) contains highly efficient generic data structures and algorithms. The STL encompasses many headers like: <code>&lt;array></code>, <code>&lt;stack></code>, <code>&lt;vector></code>, etc.</p><a href=#vector><h2 id=vector><span class=hanchor arialabel=Anchor># </span><code>&lt;vector></code></h2></a><p>&lsquo;Vector&rsquo; isn&rsquo;t the best name. It should be called &lsquo;
<a href=https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html rel=noopener>ArrayList</a>&rsquo; or &lsquo;DynamicArray&rsquo;. It is implemented with an array under the hood.</p><ul><li>To resize the underlying array, a larger memory block is allocated and all items in the original array are copied over to the new larger one. This is an $O(n)$ operation.</li><li>Vectors consume more memory than arrays, but offers methods for runtime resizing.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;vector&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// Initialisation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>    
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Main methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>posIter</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>           <span class=c1>// O(1) - Inserts b at posIter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>posIter</span><span class=p>,</span> <span class=n>it1</span><span class=p>,</span> <span class=n>it2</span><span class=p>)</span>    <span class=c1>//        Inserts elements from it1 to it2 at posIter
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>posIter</span><span class=p>)</span>               <span class=c1>// Deletes item at posIter
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>startIter</span><span class=p>,</span> <span class=n>endIter</span><span class=p>)</span>    <span class=c1>// Deletes all elements in range from inclusive startIter to exclusive endIter
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>b</span><span class=p>)</span>                 <span class=c1>// O(1) - Append
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>pop_back</span><span class=p>()</span>                   <span class=c1>// O(1) - Pop from end
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>front</span><span class=p>()</span>                      <span class=c1>// O(1) - Peek front
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>back</span><span class=p>()</span>                       <span class=c1>// O(1) - Peek back
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>                           <span class=c1>// O(1) - Access item at an index (the same way you would for arrays)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>at</span><span class=p>(</span><span class=n>i</span><span class=p>)</span>                        <span class=c1>//        Alternative to []. It throws an exception for out of bounds access
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Iterators
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span>               <span class=c1>// Iterator starting from first element (index 0)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>end</span><span class=p>()</span>                 <span class=c1>// Iterator starting from last element
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>rbegin</span><span class=p>()</span>              <span class=c1>// Reversed
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>rend</span><span class=p>()</span>                
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>cbegin</span><span class=p>()</span>              <span class=c1>// Read-only iterator
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>cend</span><span class=p>()</span>                
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Properties
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>max_size</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>capacity</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>Slicing and splicing:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Slicing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span><span class=o>&lt;</span><span class=k>typename</span> <span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>slice</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span> <span class=p>{</span>     
</span></span><span class=line><span class=cl>        <span class=c1>// Returns a new vector from inclusive start to exclusive end
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=n>first</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>cbegin</span><span class=p>()</span> <span class=o>+</span> <span class=n>start</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>last</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>cbegin</span><span class=p>()</span> <span class=o>+</span> <span class=n>end</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>sliced</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>last</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sliced</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Splicing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span> <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>a</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>b</span><span class=p>.</span><span class=n>begin</span><span class=p>(),</span> <span class=n>b</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>     <span class=c1>// a is now { 1, 4, 5, 2, 3 }
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>a</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>2</span><span class=p>,</span> <span class=n>a</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span> <span class=o>+</span> <span class=mi>3</span><span class=p>);</span>           <span class=c1>// a is now { 1, 4, 2, 3 } 
</span></span></span></code></pre></td></tr></table></div></div><a href=#set><h2 id=set><span class=hanchor arialabel=Anchor># </span><code>&lt;set></code></h2></a><p>Stores elements in sorted order without duplicates. For most use cases, you probably want to use <code>unordered_set</code> instead, which has more favourable time complexities.</p><ul><li>The underlying implementation uses a balanced tree.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>set</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>)</span>      <span class=c1>// O(logn) - Inserts element
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>)</span>        <span class=c1>// O(logn) - Gets an element
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=c1>//           Returns an iterator which points to the value if it was
</span></span></span><span class=line><span class=cl><span class=c1></span>                      <span class=c1>//           found, otherwise it points to s.end().
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>              <span class=c1>// O(1)    - Cardinality.
</span></span></span></code></pre></td></tr></table></div></div><a href=#unordered_set><h2 id=unordered_set><span class=hanchor arialabel=Anchor># </span><code>&lt;unordered_set></code></h2></a><p>Same as <code>std::set</code> from <code>&lt;set></code>, just unordered.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// CRUD:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>)</span>      <span class=c1>// O(1) 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>)</span>        <span class=c1>// O(1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>erase</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Properties:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>              <span class=c1>// O(1)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>Uses a hash table as the underlying data structure.</li></ul><a href=#map><h2 id=map><span class=hanchor arialabel=Anchor># </span><code>&lt;map></code></h2></a><p>A data structure mapping a set of keys to values. This one maintains order of keys. If this is irrelevant (which it usually is), use <code>unordered_map</code> instead.</p><ul><li>Implemented with a self-balancing binary search tree.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Main operations
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>pair</span><span class=p>)</span>      <span class=c1>// Takes in std::pair&lt;keyT, valT&gt;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>[</span><span class=n>key</span><span class=p>]</span> <span class=o>=</span> <span class=n>val</span>        <span class=c1>// More straightforward way to add key-value pairs
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>key</span><span class=p>)</span>        <span class=c1>// Deletes key-value pair by key. Doesn&#39;t fail if the key doesn&#39;t exist
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Iterators
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>begin</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>end</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// ... and all the other ones available to classes like std::vector
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Properties
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>m</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>max_size</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>m</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>There are
<a href=https://stackoverflow.com/questions/17172080/insert-vs-emplace-vs-operator-in-c-map rel=noopener>multiple ways</a> to insert key-value pairs into a map, eg. <code>insert()</code>, <code>[ ]</code> operator, <code>emplace()</code>, etc.</li></ul><p>Usage example:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Adding key-value pairs:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>map</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>frequencies</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>frequencies</span><span class=p>[</span><span class=s>&#34;Hello&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>4</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>frequencies</span><span class=p>[</span><span class=s>&#34;World&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>val</span> <span class=o>=</span> <span class=n>frequencies</span><span class=p>[</span><span class=s>&#34;World&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Iterating through key-value pairs:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>frequencies</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>it</span> <span class=o>!=</span> <span class=n>frequencies</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>it</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>first</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; : &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><a href=#unordered_map><h2 id=unordered_map><span class=hanchor arialabel=Anchor># </span><code>&lt;unordered_map></code></h2></a><p>The interface is very similar to <code>std::map</code> from <code>&lt;map></code>, however it offers a few more lower-level methods like <code>bucket_count()</code>, <code>load_factor()</code>, etc.</p><a href=#array><h2 id=array><span class=hanchor arialabel=Anchor># </span><code>&lt;array></code></h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Initialisation
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>3</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>     <span class=c1>// [1, 2, 3]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>nums</span><span class=p>[]</span>  <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span> <span class=p>};</span>     <span class=c1>// [1, 2, 3]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span> <span class=mi>1</span> <span class=p>};</span>           <span class=c1>// [1, 0, 0]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>nums</span><span class=p>[</span><span class=mi>3</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>  <span class=p>};</span>            <span class=c1>// [0, 0, 0]
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// TODO: Utility functions
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>fill_n</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>To get the size of an array, you’d need to do $\texttt{sizeof(arr) / sizeof(arr[0])}$. It is almost always recommended to use <code>std::vector</code> over regular arrays
<a href=https://stackoverflow.com/questions/2037736/how-to-find-the-size-of-an-int rel=noopener></a>.</li></ul><a href=#stack><h2 id=stack><span class=hanchor arialabel=Anchor># </span><code>&lt;stack></code></h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stack&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>stack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Main methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>item</span><span class=p>);</span>      
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>top</span><span class=p>()</span>          <span class=c1>// Reads the top element
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span>          <span class=c1>// Removes the top element. Doesn&#39;t actually return anything
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>s</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><a href=#queue><h2 id=queue><span class=hanchor arialabel=Anchor># </span><code>&lt;queue></code></h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;queue&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>queue</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>q</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Main methods
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>q</span><span class=p>.</span><span class=n>push</span><span class=p>()</span>   
</span></span><span class=line><span class=cl><span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>()</span>          <span class=c1>// Reads the next element
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>q</span><span class=p>.</span><span class=n>back</span><span class=p>()</span>           <span class=c1>// Reads the last element
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span>            <span class=c1>// Removes the top element. Doesn&#39;t actually return anything
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>q</span><span class=p>.</span><span class=n>size</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><a href=#tuple><h2 id=tuple><span class=hanchor arialabel=Anchor># </span><code>&lt;tuple></code></h2></a><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Construct tuples with `std::make_tuple`   
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>person</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Access tuple values with `std::get`. Tuples don&#39;t work with the subscript operator [] unfortunately. Reason: https://stackoverflow.com/questions/32606464/why-can-we-not-access-elements-of-a-tuple-by-index.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>0</span><span class=o>&gt;</span><span class=p>(</span><span class=n>person</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>get</span><span class=o>&lt;</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>(</span><span class=n>person</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// You can also construct tuples with `std::make_tuple`. This is better
</span></span></span><span class=line><span class=cl><span class=c1>// when you want to pass a tuple r-value to a function because `make_tuple`
</span></span></span><span class=line><span class=cl><span class=c1>// can infer types. See: https://stackoverflow.com/questions/34180636/what-is-the-reason-for-stdmake-tuple
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>tuple</span><span class=o>&lt;</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>person</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_tuple</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><a href=#algorithm-todo><h1 id=algorithm-todo><span class=hanchor arialabel=Anchor># </span><code>&lt;algorithm></code> [TODO]</h1></a><a href=#io-todo><h1 id=io-todo><span class=hanchor arialabel=Anchor># </span>I/O [TODO]</h1></a><p>In computer science, a stream is an abstraction that represents a sequence of data that arrives over time (much like a conveyor belt delivering items). In C++, this stream abstraction is how we work with reading/writing characters coming from an input stream (eg. user input on the terminal or a file in read mode) or being written to an output stream (eg. the terminal or a file in write mode).</p><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/Untitled%206.png width=auto alt=Untitled></p><a href=#ostream><h3 id=ostream><span class=hanchor arialabel=Anchor># </span><code>ostream</code></h3></a><p>An <code>ostream</code> serialises typed values as bytes and dumps them somewhere.</p><ul><li>The ‘put to’ operator <code>&lt;&lt;</code> is used on objects of type <code>ostream</code>.</li><li><code>std::cout</code> and <code>std::err</code> are both objects of type <code>ostream</code>.</li></ul><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/Untitled%207.png width=auto alt=Untitled></p><hr><ul><li><p>You can chain the put-to operator <code>&lt;&lt;</code> because the result of an expression like <code>cout &lt;&lt; “Hello”</code> is itself an <code>ostream</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello, &#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;world.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>You can overload the &#171; operator for your own classes. Example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>age</span><span class=p>)</span> <span class=o>:</span> <span class=n>name_</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>age_</span><span class=p>(</span><span class=n>age</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>Serialise</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;(name: &#34;</span> <span class=o>+</span> <span class=n>name_</span> <span class=o>+</span> <span class=s>&#34;)&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>name_</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>age_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ostream</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>&lt;&lt;</span><span class=p>(</span><span class=n>ostream</span><span class=o>&amp;</span> <span class=n>os</span><span class=p>,</span> <span class=k>const</span> <span class=n>Person</span><span class=o>&amp;</span> <span class=n>person</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os</span> <span class=o>&lt;&lt;</span> <span class=n>person</span><span class=p>.</span><span class=n>Serialise</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>os</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=n>person</span><span class=p>(</span><span class=s>&#34;Andrew&#34;</span><span class=p>,</span> <span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>person</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#iomanip-todo><h3 id=iomanip-todo><span class=hanchor arialabel=Anchor># </span><code>iomanip</code> [TODO]</h3></a><a href=#istream><h3 id=istream><span class=hanchor arialabel=Anchor># </span><code>istream</code></h3></a><p>An <code>istream</code> takes in bytes and converts it to typed values.</p><ul><li>The ‘get from’ operator <code>>></code> is used as an input operator</li><li><code>std::cin</code> is the standard input stream</li></ul><p><img src=https://wiki.timz.dev//Knowledge/Engineering/Languages/assets/Untitled%208.png width=auto alt=Untitled></p><hr><ul><li><p>Formatted extraction:
The type of the RHS of the ‘get from’ operator determines what input is accepted</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>i</span><span class=p>;</span>    <span class=c1>// Expects an integer value to be supplied
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>double</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>j</span><span class=p>;</span>    <span class=c1>// Expects a floating point value to be supplied
</span></span></span></code></pre></td></tr></table></div></div><ul><li><p>You can chain the get-from operator <code>>></code> just like for put-to <code>&lt;&lt;</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>i</span> <span class=o>&gt;&gt;</span> <span class=n>j</span><span class=p>;</span>   <span class=c1>// Expects an integer, and then a double
</span></span></span></code></pre></td></tr></table></div></div></li><li><p>The user input can be space-separated, new-line-separated or tab-separated integers. There can be any number of &rsquo; &lsquo;, &lsquo;\n&rsquo;, &lsquo;\t&rsquo; characters between the integers</p></li><li><p>If what the user types in cannot be casted to the expected type, nothing happens. The program continues execution and the variable ends up being uninitialised</p></li></ul></li><li><p>Unformatted line extraction with <code>std::getline</code>
When you want to read an entire line up to and not including the newline character, you should use <code>getline</code> rather than directly read from <code>cin</code> (which always considers space characters &rsquo; &lsquo;, &lsquo;\n&rsquo;, &lsquo;\t&rsquo; to be terminating)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>string</span> <span class=n>msg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>msg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// If the user types: hello world, then msg will only be &#34;hello&#34;.
</span></span></span><span class=line><span class=cl><span class=c1>// If you want to capture the entire line instead, use getline
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>getline</span><span class=p>(</span><span class=n>cin</span><span class=p>,</span> <span class=n>msg</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Common pitfall: when you do formatted execution followed by unformatted extraction, you’ll skip over the unformatted extraction.
This is fixed with <code>std::cin.ignore()</code></p><p><a href=https://stackoverflow.com/questions/21567291/why-does-stdgetline-skip-input-after-a-formatted-extraction rel=noopener>Source</a></p><p>Suppose you have:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>age</span><span class=p>;</span>                     <span class=c1>// You type: 10
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>getline</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>,</span> <span class=n>name</span><span class=p>);</span>        <span class=c1>// You type: Andrew
</span></span></span></code></pre></td></tr></table></div></div><p>You are actually typing “10\n” for the first input prompt. The “\n” unfortunately remains in the buffer when we get to the next <code>getline</code> call, which terminates immediately upon seeing the newline, thereby skipping input extract.</p><p>To solve this, you need to call <code>std::cin.ignore()</code> to skip over the newline.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>std::cin &gt;&gt; age;
</span></span><span class=line><span class=cl>std::cin.ignore();
</span></span><span class=line><span class=cl>std::getline(std::cin, name);
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#file-manipulation-fstream><h2 id=file-manipulation-fstream><span class=hanchor arialabel=Anchor># </span>File Manipulation (<code>fstream</code>)</h2></a><p>The <code>fstream.h</code> header defines <code>ifstream</code>, which you use to open a file in read mode, <code>ofstream</code>, which you use to open a file in write mode, and <code>fstream</code> which you can use to create, read and write to files.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ═════ Opening a file for reading ═════
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ifstream</span> <span class=nf>test_file</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>getline</span><span class=p>(</span><span class=n>test_file</span><span class=p>,</span> <span class=n>line</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Read line: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>line</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>test_file</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ═════ Opening a file for writing (truncating) ═════
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ofstream</span> <span class=nf>test_file</span><span class=p>(</span><span class=s>&#34;out.test.txt&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>test_file</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>test_file</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// ═════ Opening a file for writing (appending) ═════
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ofstream</span> <span class=nf>test_file</span><span class=p>(</span><span class=s>&#34;out.test.txt&#34;</span><span class=p>,</span> <span class=n>ios</span><span class=o>::</span><span class=n>app</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>line</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>test_file</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello world</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>test_file</span><span class=p>.</span><span class=n>close</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><aside>ℹ️ Note that `ofstream` is a subclass of `ostream` and `ifstream` is a subclass of `istream`, meaning that you get to use `<<` to write and `>>` to read and work with them in the same way that you work with `cout` and `cin`.</aside><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// ifstream member methods:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>in</span><span class=p>.</span><span class=n>eof</span><span class=p>();</span>      <span class=c1>// Returns true if EOF has been reached.
</span></span></span></code></pre></td></tr></table></div></div><a href=#string-streams-sstream><h2 id=string-streams-sstream><span class=hanchor arialabel=Anchor># </span>String Streams (<code>sstream</code>)</h2></a><p>String streams let you treat instances of <code>std::string</code> as stream objects, letting you work with them in the same way that you’d work with <code>cin</code>, <code>cout</code> of file streams.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// You can use `istringstream` anywhere you use `istream`. You can use this to feed strings to something that expects input.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>istringstream</span> <span class=n>str_in</span><span class=p>(</span><span class=s>&#34;42 12 24&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>str_in</span> <span class=o>&gt;&gt;</span> <span class=n>a</span> <span class=o>&gt;&gt;</span> <span class=n>b</span> <span class=o>&gt;&gt;</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Similarly, `ostringstream` can substitute for `ostream` instances. You can use this to capture output into a string.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>ostringstream</span> <span class=n>str_out</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>str_out</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Hello world&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>extracted</span> <span class=o>=</span> <span class=n>str_out</span><span class=p>.</span><span class=n>str</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><a href=#filesystem><h2 id=filesystem><span class=hanchor arialabel=Anchor># </span>Filesystem</h2></a><p>C++17 gives us the <code>std::filesystem</code> API which finally lets us basically do <code>ls</code> on directories and traverse the filesystem, create symbolic links, get file stats, etc.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// Loops through all files in the given directory.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>std</span><span class=o>::</span><span class=n>filesystem</span><span class=o>::</span><span class=n>directory_entry</span><span class=o>&amp;</span> <span class=nl>each_file</span> <span class=p>:</span> <span class=n>std</span><span class=o>::</span><span class=n>filesystem</span><span class=o>::</span><span class=n>directory_iterator</span><span class=p>(</span><span class=s>&#34;/usr/bin&#34;</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>each_file</span><span class=p>.</span><span class=n>path</span><span class=p>()</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><a href=#memory><h1 id=memory><span class=hanchor arialabel=Anchor># </span>Memory</h1></a><a href=#memory-1><h2 id=memory-1><span class=hanchor arialabel=Anchor># </span><code>&lt;memory></code></h2></a><p><code>&lt;memory></code> provides two smart pointers: <code>unique_ptr</code> and <code>shared_ptr</code>, for managing objects allocated on the heap.</p><p>Use smart pointers whenever you need pointer semantics. The main time you do is when you want to make use of a polymorphic object. You do not need pointer semantics when returning things from a function because that will be handled by copy and move (furthermore, copy elision ensures no unnecessary copies).</p><a href=#unique_ptr><h3 id=unique_ptr><span class=hanchor arialabel=Anchor># </span><code>unique_ptr</code></h3></a><p>By giving a pointer to <code>unique_ptr</code>, we can have confidence that when that <code>unique_ptr</code> goes out of scope, the object it tracks gets deallocated in the destructor of <code>unique_ptr</code>.</p><ul><li>It&rsquo;s recommended to use <code>make_unique&lt;Foo>(...).</code> instead of <code>unique_ptr&lt;T>(new Foo(...))</code>, mainly so you can completely eliminate the usage of naked <code>new</code> and <code>delete</code>s.</li><li>Since <code>unique_ptr</code> represents sole ownership, its copy constructor and assignment operation are disabled. You can use move semantics to transfer the <code>unique_ptr</code> from one variable to another.</li><li>You can pass and return <code>unique_ptr</code>s in functions (by value).<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>make_foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=mi>42</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><a href=https://stackoverflow.com/questions/4316727/returning-unique-ptr-from-functions rel=noopener>Wait, why is this allowed when the copy operation is disabled?</a> Basically, it is guaranteed for either copy elision to happen or for <code>std::move</code> to be implicitly called on the return value. Either way, the caller of <code>make_foo</code> is guaranteed sole ownership.<blockquote><p>&ldquo;The part of the Standard blessing the RVO goes on to say that if the conditions for the RVO are met, but compilers choose not to perform copy elision, the object being returned must be treated as an rvalue. In effect, the Standard requires that when the RVO is permitted, either copy elision takes place or <code>std::move</code> is implicitly applied to local objects being returned.&rdquo; — Scott Meyers.</p></blockquote></li><li><a href="https://www.internalpointers.com/post/move-smart-pointers-and-out-functions-modern-c#:~:text=Return-smart-pointers-from-functions" rel=noopener>Always return smart pointers by value</a>.</li></ul></li></ul><blockquote><p>&ldquo;The code using <code>unique_ptr</code> will be exactly as efficient as code using the raw pointers correctly.&rdquo; — Bjarne Stroustrup, A Tour of C++.</p></blockquote><a href=#shared_ptr><h3 id=shared_ptr><span class=hanchor arialabel=Anchor># </span><code>shared_ptr</code></h3></a><p>Similar to <code>unique_ptr</code>, but <code>shared_ptr</code>s get copied instead of moved. The object held by <code>shared_ptr</code> is deleted only when no other <code>shared_ptr</code> points at it.</p><ul><li>Prefer <code>make_shared</code> over directly constructing <code>shared_ptr</code> and using <code>new</code>.</li></ul><a href=#weak_ptr-todo><h3 id=weak_ptr-todo><span class=hanchor arialabel=Anchor># </span><code>weak_ptr</code> [TODO]</h3></a><p>When you assign <code>std::shared_ptr</code> to a variable of type <code>std::weak_ptr</code>, it won’t increment the underlying references count managed by the <code>shared_ptr</code>.</p><a href=#concurrency><h1 id=concurrency><span class=hanchor arialabel=Anchor># </span>Concurrency</h1></a><a href=#thread><h2 id=thread><span class=hanchor arialabel=Anchor># </span><code>&lt;thread></code></h2></a><aside>ℹ️ On Linux, you have to compile with the flag `-pthread` to link the POSIX thread library: `g++ -pthread -o term term.c`</aside><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// When you construct a thread, it starts running the given function in a separate thread immediately.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>my_worker</span><span class=p>(</span><span class=n>func</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=n>my_worker</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>      <span class=c1>// A synchronous statement that blocks the current thread until `my_worker` has terminated.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Simple full example</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>std</span><span class=o>::</span><span class=n>literals</span><span class=o>::</span><span class=n>chrono_literals</span><span class=p>;</span>   <span class=c1>// Allows you to use time literals like `1s`, `1500ms`, etc.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=n>finished</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>DoWork</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>finished</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Working...</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>sleep_for</span><span class=p>(</span><span class=mi>1000</span><span class=n>ms</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>worker</span><span class=p>(</span><span class=n>DoWork</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cin</span><span class=p>.</span><span class=n>get</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Interrupted!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>finished</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>worker</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Worker thread has finished execution.</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#mutex><h2 id=mutex><span class=hanchor arialabel=Anchor># </span><code>&lt;mutex></code></h2></a><p><code>std::mutex</code> is a very simple lockable object used to synchronise access to a resource shared by parallel threads.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=n>unlock</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>Race condition example and how to solve it with mutexes</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>    <span class=c1>// This is a shared resource that parallel threads will try to read/write to
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>IncrementCount</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Thread with ID &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>get_id</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>                  <span class=o>&lt;&lt;</span> <span class=s>&#34; sees count as &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>count</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>IncrementCount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>IncrementCount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>The following is the output of running the program. You can see the lines being printed are also jumbled because <code>cout</code> is also a ‘resource’ being accessed by both threads. We need to lock access to <code>count</code> and <code>cout</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123004860160</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>82</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123004860160</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>83</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123013252864</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>85</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123004860160</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>14012301325286486</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> 
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123004860160</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>87</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123004860160</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>88</span>
</span></span><span class=line><span class=cl><span class=mi>86</span><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> 
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123013252864</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>90</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140123013252864</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>91</span>
</span></span></code></pre></td></tr></table></div></div><p>Solution:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;thread&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;mutex&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>mutex</span> <span class=n>count_mutex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>IncrementCount</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>count</span> <span class=o>&lt;</span> <span class=mi>100</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>count_mutex</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Thread with ID &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>this_thread</span><span class=o>::</span><span class=n>get_id</span><span class=p>()</span> 
</span></span><span class=line><span class=cl>                  <span class=o>&lt;&lt;</span> <span class=s>&#34; sees count as &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>count</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>count</span><span class=o>++</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>count_mutex</span><span class=p>.</span><span class=n>unlock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t1</span><span class=p>(</span><span class=n>IncrementCount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=kr>thread</span> <span class=n>t2</span><span class=p>(</span><span class=n>IncrementCount</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>t1</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>t2</span><span class=p>.</span><span class=n>join</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>82</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>83</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>84</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>85</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>86</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>87</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>88</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>89</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>90</span>
</span></span><span class=line><span class=cl><span class=n>Thread</span> <span class=n>with</span> <span class=n>ID</span> <span class=mi>140367027558144</span> <span class=n>sees</span> <span class=n>count</span> <span class=n>as</span> <span class=mi>91</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><a href=#future-todo><h2 id=future-todo><span class=hanchor arialabel=Anchor># </span><code>&lt;future></code> [TODO]</h2></a><a href=#async-todo><h3 id=async-todo><span class=hanchor arialabel=Anchor># </span><code>async</code> [TODO]</h3></a><a href=#utilities><h1 id=utilities><span class=hanchor arialabel=Anchor># </span>Utilities</h1></a><a href=#regex><h2 id=regex><span class=hanchor arialabel=Anchor># </span><code>&lt;regex></code></h2></a><p>Note: using raw string literals, $\texttt{R"(&mldr;)"}$, makes writing regex patterns easier because you won’t be confused about backslashes escaping things that you didn’t mean to escape.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;regex&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>regex</span> <span class=n>pattern</span><span class=p>(</span><span class=n>R</span><span class=s>&#34;(.*)&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>smatch</span> <span class=n>matches</span><span class=p>;</span>        <span class=c1>// A container for storing std::string matches (capture groups).
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=c1>// There are also other containers like std::cmatch for storing
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=c1>// string literal matches. 
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=c1>// These are all instances of std::match_results and can be
</span></span></span><span class=line><span class=cl><span class=c1></span>							<span class=c1>// indexed with the subscript operator [].
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>matches</span><span class=p>[</span><span class=n>i</span><span class=p>]</span>              <span class=c1>// Accesses the i-th match. Note: matches[1] accesses the first
</span></span></span><span class=line><span class=cl><span class=c1></span>                            <span class=c1>// match, matches[2] accesses the second match, and so on.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// ═════ Functions ═════
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>std</span><span class=o>::</span><span class=n>regex_match</span><span class=p>(</span><span class=n>haystack</span><span class=p>,</span> <span class=n>pattern</span><span class=p>);</span>            <span class=c1>// Returns true if matched.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>regex_search</span><span class=p>(</span><span class=n>haystack</span><span class=p>,</span> <span class=n>matches</span><span class=p>,</span> <span class=n>pattern</span><span class=p>);</span>  <span class=c1>// Returns true if matched. Populates the 
</span></span></span><span class=line><span class=cl><span class=c1></span>                                                <span class=c1>// std::smatch object with capture group
</span></span></span><span class=line><span class=cl><span class=c1></span>                                                <span class=c1>// matches that you can extract.
</span></span></span></code></pre></td></tr></table></div></div><a href=#c-standard-libraries-todo><h1 id=c-standard-libraries-todo><span class=hanchor arialabel=Anchor># </span>C Standard Libraries [TODO]</h1></a></article><hr><div class=page-end><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li><a href=/ data-ctx="C++ Standard Library" data-src=/ class=internal-link>Tim's Dev Wiki</a></li><li><a href=/Knowledge/Engineering/Languages/C++/ data-ctx="C++ standard library" data-src=/Knowledge/Engineering/Languages/C++ class=internal-link>C++</a></li></ul></div></div><div id=contact_buttons><footer><ul><li><a href=/>Home</a></li><li><a href=https://timz.dev>timz.dev</a></li><li><a href=https://github.com/Tymotex/wiki>Github</a></li><li><a href=https://www.linkedin.com/in/timz-seng>LinkedIn</a></li></ul><p>Tim Zhang © 2023</p></footer></div></div></body></html>